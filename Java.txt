jdk1.8.0_181

https://docs.oracle.com/javase/8/docs/

Java Runtime Environment (JRE), está formado por Java Virtual Machine (JVM), clases del núcleo de la plataforma Java y bibliotecas de la plataforma Java de soporte. JRE es la parte de tiempo de ejecución del software de Java, que es todo lo que necesita para ejecutarlo en el explorador web.

¿Qué es el software del plugin de Java?
El software del plugin de Java es un componente de Java Runtime Environment. JRE permite applets escritos en el lenguaje de programación de Java para ejecutar en varios exploradores. El software del plugin de Java no es un programa autónomo y no se puede instalar de forma independiente.

Java Virtual Machine es sólo un aspecto del software de Java que interviene en interacción web. Java Virtual Machine está incorporado en la descarga del software de Java y ayuda a ejecutar las aplicaciones Java.

https://docs.oracle.com/javase/7/docs/technotes/guides/jweb/index.html

http://www.oracle.com/technetwork/java/javase/overview/index.html

http://www.oracle.com/technetwork/java/javase/jdk-8-readme-2095712.html#introduction

https://www.oracle.com/java/technologies/javameoverview.html

http://java.sun.com <==> https://www.oracle.com/java/technologies/

https://javacook.darwinsys.com/download.html

https://github.com/IanDarwin/javasrc

https://docs.oracle.com/en/java/java-components/jdk-mission-control/
https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html
https://docs.oracle.com/javase/8/docs/api/overview-summary.html
https://docs.oracle.com/javase/8/docs/technotes/tools/unix/toc.html
https://docs.oracle.com/javase/8/javase-books.htm
https://docs.oracle.com/javase/8/docs/api/
    
https://www.oracle.com/technetwork/java/javase/overview/index.html
https://code.visualstudio.com/docs/java/java-tutorial

Instalation: https://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html#CJAGAACB

For example, if you were downloading the JDK (Java Development Kit) installer for 32-bit systems for update 1.8.0_01, the file name: jdk-8version-windows-i586.exe becomes jdk-8u1-windows-i586.exe.

JDK includes the JRE.

------ Esto es viejo... npi 
------ --O-J-O--
PATH
D:\Mis Documentos\Development\Java\JBobadilla;
which java
java -version

adding one of the following lines to your ~/.bash_profile file 

export JAVA_HOME="$(/usr/libexec/java_home -v 1.8)”

echo $JAVA_HOME
/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home

- Para instalar Java en Ubuntu usando los files binarie Open JDK 8: 
$ sudo apt install openjdk-8-jdk
- Instalar Java en Ubuntu a través de PPA
  Añadir el Repositorio PPA de Webupd8 para Ubuntu 18.04 Bionic Beaver:
$ sudo add-apt-repository ppa:webupd8team/java
$ sudo apt update

$ sudo apt search oracle-java
$ sudo apt install oracle-java8-set-default
$ sudo add-apt-repository ppa:linuxuprising/java version 10
$ sudo apt install default-jre            
$ sudo apt install openjdk-11-jre-headless
$ sudo apt install openjdk-8-jre-headless 
$ java -version

$ sudo apt install openjdk-8-jdk openjdk-8-jre
JAVA_HOME= /usr/lib/jvm/java-8-openjdk-amd64
/opt/java-jdk/jdk1.8.0_231
JRE_HOME=/usr/lib/jvm/java-8-openjdk-amd64/jre
/opt/java-jdk/jdk1.8.0_231/jre

$ grep -f pattern_file *.java
cat pattern_file
assert

grep -n 'something' *.java
find -name '*Listener'*.Java
find -name 'Listener?'*.java
find -name 'StringAlign'*

         1         2         3         4         5         6         7         8         9         0         1         2         3
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890

https://www.geeksforgeeks.org/java/?ref=grb

execute
cd /home/hadoop/SCProjects/0_SCProjects_github.com_SCelisV/_JavaDevelopment/testjdk_1.8.0_292/src ; /usr/bin/env /usr/lib/jvm/java-11-openjdk-amd64/bin/java -Dfile.encoding=UTF-8 -cp /home/hadoop/.config/Code/User/workspaceStorage/25fa5dc2bf9cb43a259787a70c062b18/redhat.java/jdt_ws/src_5bfeb882/bin Calculadora1

objects..??
ls /home/hadoop/.config/Code/User/workspaceStorage/25fa5dc2bf9cb43a259787a70c062b18/redhat.java/jdt_ws/src_5bfeb882/bin/
??
/home/hadoop/SCProjects/0_SCProjects_github.com_SCelisV/_JavaDevelopment/testjdk_1.8.0_292/src

https://es.atlassian.com/git

https://jarroba.com/annotations-anotaciones-en-java/

https://javadesdecero.es/

http://www.jtech.ua.es/dadm/restringido/java/index.html
http://www.jtech.ua.es/dadm/restringido/java/index.html#Sesiones

everyday.html

Palabras Reservadas en Java:

abstract	    assert	boolean	    break	byte	    case	catch	    char	    class	    const	continue
default	        do	    double	    else	enum	    extends	false	    final	    finally	    float	for
goto	        if	    implements	import	instanceof	int	    interface	long	    native	    new	    null
package	        private	protected	public	return	    short	static	    strictfp	String	    super	switch
synchronized	this	throw	    throws	transient	true	try	        void	    volatile	while	 

nuevas palabras clave context-sensitive JDK 9 
open	        module	requires	transitive
exports	        opens	to	        uses
provides	    with

Java a través de ejemplos - Jesus Bobadilla - ISBN: 9788478975495

compile: javac HolaMundo.java
execute: java HolaMundo

_JavaDevelopment/testjdk_1.8.0.292/src/HolaMundo.java

Operadores - Casting 
Tipos de datos primitivos byte, short, int, long, char, float, double y boolean

Operadores - Casting 
_JavaDevelopment/testjdk_1.8.0.292/src/Casting.java

Tipos de datos primitivos byte, short
_JavaDevelopment/testjdk_1.8.0.292/src/TiposEnteros1.java

Tipos de datos primitivos int, long
_JavaDevelopment/testjdk_1.8.0.292/src/TiposEnteros2.java

Tipos de datos primitivos float, double
_JavaDevelopment/testjdk_1.8.0.292/src/TiposDecimales.java

Tipos de datos primitivos boolean
_JavaDevelopment/testjdk_1.8.0.292/src/TipoBooleano.java

Tipos de datos primitivos char
_JavaDevelopment/testjdk_1.8.0.292/src/Tipocaracter.java

int entero1; --> tipo primitivo
Las variables de tipo int almacenan el valor binario real para el entero que representan.

| Uso                                                         | int | Integer |
|-------------------------------------------------------------|-----|---------|
| Cálculos con + - * / % ^ etc.                               | sí  | no      |
| Pasar como parámetro                                        | sí  | sí      |
| Retornar como un valor                                      | sí  | sí      |
| Usar métodos desde java.lang.Integer                        | no  | sí      |
| Almacenarlo en un Vector o en otra Colección                | no  | sí      |
| Usarlo como una llave de HashMap                            | no  | sí      |
| Serializarlo                                                | no  | sí      |
| Pasarlo como un objeto genérico (TableCellRenderer)         | no  | sí      |
| Admitir como un valor nulo para significar que no hay valor | no  | sí      |
| Enviarse a sí mismo por RMI (Remote Method Invocation)      | no  | sí      |
| Enviarlo como parte de otro Objeto a través de RMI          | sí  | sí      |

Integer entero2; --> tipo referencia
es una Clase, como cualquier otra clase de Java, con sus métodos
Integer.parseInt ("1");
Los objetos Integer son inmutables.

primitivo byte    objeto byte
primitivo short   objeto Short
primitivo int     objeto Integer
primitivo long    objeto Long
primitivo boolean objeto Boolean
primitivo char    objeto Char
primitivo float   objeto Float
primitivo double  objeto Double

Autoboxing: conversión automática que hace el compilador Java entre los tipos primitivos y sus correspondientes clases de contenedor de objetos
int a Integer, double a Double etc

List<Integer> li = new ArrayList<>();
for (int i = 1; i < 50; i += 2)
     li.add(i);

List<Integer> li = new ArrayList<>();
for (int i = 1; i < 50; i += 2)
    li.add(Integer.valueOf(i));    

Unboxing: conversión de un objeto de un tipo de contenedor (Integer) en su valor primitivo (int) 

public static int sumEven(List<Integer> li) {
    int sum = 0;
    for (Integer i: li)
        if (i % 2 == 0)
            sum += i;
        return sum;
}

public static int sumEven(List<Integer> li) {
    int sum = 0;
    for (Integer i : li)
        if (i.intValue() % 2 == 0)
            sum += i.intValue();
        return sum;
}

Operadores Aritmeticos *, +, -, /, (% int resto ó modulo), ++Variable, Variable++, --Variable, Variable--
_JavaDevelopment/testjdk_1.8.0.292/src/OperadoresAritmeticos.java
Operadores Logicos !, &&, ||
_JavaDevelopment/testjdk_1.8.0.292/src/OperadoresLogicos.java

Operadores de Comparacion <, <=, >, >=, ==, !=
_JavaDevelopment/testjdk_1.8.0.292/src/OperadoresComparacion.java

Estructuras de control: Bucles - For 
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor1.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor2.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor3.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor4.java
_JavaDevelopment/testjdk_1.8.0.292/src/Logistica.java
_JavaDevelopment/testjdk_1.8.0.292/src/Factorial.java

_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor5.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor6a.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor6.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor7.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor8.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleFor9.java

Estructuras de control: Bucles - While - do While
_JavaDevelopment/testjdk_1.8.0.292/src/BucleWhile3.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleWhile2.java
_JavaDevelopment/testjdk_1.8.0.292/src/BucleWhile1.java

Constantes - For anidado
_JavaDevelopment/testjdk_1.8.0.292/src/Primo.java

IF - IF ELSE - ANIDADOS
_JavaDevelopment/testjdk_1.8.0.292/src/IF8.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF7.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF6.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF5.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF4.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF3.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF2.java
_JavaDevelopment/testjdk_1.8.0.292/src/IF1.java
_JavaDevelopment/testjdk_1.8.0.292/src/EcuacionGrado2.java
_JavaDevelopment/testjdk_1.8.0.292/src/PuntodeCorte.java
_JavaDevelopment/testjdk_1.8.0_292/src/multipleChoice.java

SWITCH - SWITCH - ANIDADOS
Switch - byte - final - sin break
_JavaDevelopment/testjdk_1.8.0.292/src/Switch9.java
Switch - byte - sin break
_JavaDevelopment/testjdk_1.8.0.292/src/Switch8.java
Switch - byte
_JavaDevelopment/testjdk_1.8.0.292/src/Switch7a.java
_JavaDevelopment/testjdk_1.8.0.292/src/Switch7.java
Switch - int
_JavaDevelopment/testjdk_1.8.0.292/src/Switch1.java
_JavaDevelopment/testjdk_1.8.0.292/src/Switch4.java
Switch - char
_JavaDevelopment/testjdk_1.8.0.292/src/Switch2.java
_JavaDevelopment/testjdk_1.8.0.292/src/Switch3.java
Switch - Anidado - char
_JavaDevelopment/testjdk_1.8.0.292/src/Switch5.java
IF - Anidado - char
_JavaDevelopment/testjdk_1.8.0.292/src/Switch6.java

FOR - MATH - SQRT
Math.sqrt(valor_double) --> esto es porque el método sqrt de la clase Math es estático.
_JavaDevelopment/testjdk_1.8.0.292/src/Hipotenusa.java

Creado el proyecto: testjdk_1.8.0_292

MÉTODOS (Procedimientos, funciones, subrutinas), nos permiten encapsular un conjunto de instrucciones de manera que puedan ser ejecutadas desde diferente puntos de la aplicación. 
Cuando se utiliza un método, se realiza una llamada provocando la ejecución de sus instrucciones y devolviendo, posteriormente, el flujo de control al programa que llama al método.
No todos los métodos devuelven valores al programa principal, sólo lo hacen si es necesario.

void --> indica que el método no devuelve ningún valor.

Llamadas a un método desde el programa llamante
método()
método(argumentos)

Parámetros: son variables que utiliza el método como valores de partida para sus cálculos. 
su visibilidad y ámbito(existencia), se limitan a los del propio método.

Argumentos: son valores que se establecen en el programa llamante y que se traspasan (por valor o referencia) al método llamado.

When is an attribute accessible in a class?
It is always accessible inside a class.
An attribute variable is accessible to every fucntion and constructor inside the class.

public Rectangle(double length, double width){      // parameters

    // initialize the attributes
    this.length = length;
    this.width = width;
}

we would use the this keyword when you need to make a distinction between an attribute variable and a parameter.
the this allows you to access the attributes inside the class.

Return: debe ser la última del método.
cuando el método no devuelve un valor (void), no es necesario utilizar return, o utilizarla sin un valor asociado.

// Return el valor de la hipotenusa de tipo double - no tiene clausula Return - Es static
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo1.java

// tipo de retorno void, no es necesario utilizar return, o 
// se puede utilizarla sin un valor asociado.
// programa llamante
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo2.java

Paso de argumentos por VALOR y por REFERENCIA
por VALOR
Los argumentos de tipos básicos (primitivos) del lenguaje se pasan a los parámetros POR VALOR, 
esto quiere decir que NO SE TRASPASAN los propios datos, sino una COPIA de los mismos.
tipo byte, short, int, long, char, float, double y boolean
NUNCA se modifican en el programa llamante (aunque sus copias varian en el método llamado)
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo2valor.java

por REFERENCIA - Reference Types like String, 
Lo que se copia no es el valor del argumento, sino su APUNTADOR(dirección), a la estructura de datos
Es decir, se modifica el valor de la estructura de datos donde apunta el parámetro, 
que es el mismo lugar donde apunta el argumento.
Cuando se realiza un paso de argumentos por referencia, los argumentos varían en la misma medida que varian los parámetros.
Para evitar que los parámetros no puedan modificarse podemos declararlos con final
_JavaDevelopment/testjdk_1.8.0.292/src/Metodo2referencia.java
_JavaDevelopment/javasrc-main/src/testing/atributoFinal.java

STRINGS - INMUTABLE - tienen métodos
Los Strings no forman parte de los tipops nativos de Java, sino que existe una clase String(java.lang.String)
Ex: Se declara una estructura de datos basada en el String como parámetros del método main.
Una Instancia de un String es una posición de memoria que apunta hacia una estructura de datos que contiene el conjunto de carácteres que define el String.
un String declarado pero sin definir, NO apunta hacia ninguna estructura de datos, su valor es null.
es diferente a una instancia del objeto String que apunta hacia un conjunto de carácteres vacio.

Dos instancias de un String apuntando hacia contenidos idénticos, no significa que sean iguales.

Para poder comparar dos Strings por su contenido ( y no por su referencia), podemos utilizar el método equals de la clase. 
(compara carácter a carácter.)

Ejemplos del libro
_JavaDevelopment/testjdk_1.8.0.292/src/String1_0.java
_JavaDevelopment/testjdk_1.8.0.292/src/String2_0.java

Otros ejemplos
_JavaDevelopment/testjdk_1.8.0.292/src/String1.java
_JavaDevelopment/testjdk_1.8.0.292/src/String1equals.java

métodos: length(), toUppeCase(), toLowerCase(), substring(), IndexOf, endsWith, equals, lastIndexOf
_JavaDevelopment/testjdk_1.8.0.292/src/String2.java































Matrices - Arrays - Vectores
posibilidad para recorrer sus elementos con una instrucción repetitiva

matriz unidimensional de String donde se colocan los posibles parámetros que deseamos pasar al invocar el programa: public static void main (String [] args) 

matriz lineal - int - 2 posiciones - Posicion[0], Posicion[1]
private int[] Posicion = new int[2];

Definición, inicialización, start en 0, Temperaturas
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz.java

Notas, Nombres y Aprobados, se definen listas de diferentes tipos y se recorren con for e imprimen.
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz1.java

Creación de métodos para mejorar la clase Matriz1.java
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz2.java

Creación de una matriz bidimensional de tipo String para almacenar los Alumnos = Nombres + Notas
Se hace uso de los método de la clase Float
parseFloat para convertir de String a float y 
toString para convertir de float a String
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz3.java

funciona la escritura desde el teclado - un sólo Scanner 
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz3Scanner.java

Implementa dos métodos con dos Scanner - Lee_String y Lee_Float
_JavaDevelopment/testjdk_1.8.0.292/src/Matriz3Scanner2.java

Do - While - final - Matriz
_JavaDevelopment/testjdk_1.8.0.292/src/GeneraPrimos.java

Do - While Anidados - Clave prefijada -
_JavaDevelopment/testjdk_1.8.0.292/src/RevientaClaves.java
Saber los carácteres del "abcedario"
_JavaDevelopment/testjdk_1.8.0.292/src/RevientaClaves2.java

Utilización de matrices lineales de elementos. - media, variación con respecto de la media, extremos 
_JavaDevelopment/testjdk_1.8.0.292/src/Estadisticas.java

Objetos Class (clases), soportan la programación orientada a objetos, son la estructura básica sobre la que se desarrollan las aplicaciones.

Permite definir propiedades y métodos (attributes and behavior) relacionados entre sí.

Las propiedades variables que almacenan el estado de la clase.
Los métodos son los programas que se utilizan para consultar y modificar el contenido de las propiedades.

Sintaxis de una clase:

AtributoAcceso class NombreClase {
    // propiedades y métodos
}

Un ejemplo de clase podría ser un semáforo de circulación, cuyo estado se guarde en una propiedad 
EstadoSemaforo de tipo String que pueda tomar los valores "Verde", "Amarillo, y "Rojo"
Como métodos de acceso a la propiedad podríamos  definir: PonColor(String Color) y String DimeColor().

------Semaforo.java------------------
|  Propiedad private                 |
|  -------------------------         |
|  | String EstadoSemaforo |         |
|  -------------------------         |                     Métodos public
|                              --------------------------
|                              | PonColor(String Color) | public - me permite acceder al private 
|                              --------------------------          EstadoSemaforo 
|                                    |
|                              -----------------------
|                              | String DimeColor () | public
|                              -----------------------
|                                    |
--------------------------------------

AtributoAcceso:

    Es estrictamente necesario que los atributos de una clase sean privados.
    // private no es accesible directamente desde el exterior de la clase

    // public son accesibles directamente desde el exterior de la clase

El acceso a los atributos (private) de la clase se consigue por medio de los métodos get y set.

private --> puede ser accedido únicamente por la misma clase, sus métodos o constructores

Si no usamos un modificador de acceso, el atributo sera default.
default -->  permite que tanto la propia clase como las clases del mismo paquete accedan a dichos componentes
    
protected --> permite acceso a los componentes desde la misma clase, clases del mismo paquete y clases que hereden de ella (incluso en diferentes paquetes)

public --> tendremos acceso al componente desde cualquier clase o instancia sin importar el paquete o procedencia de ésta


Modificadores de acceso - controlan el nivel de acceso
- Para las clases, se puede utilizar public o default:
  - public La clase es accesible por cualquier otra clase
  - default La clase sólo es accesible por las clases del mismo paquete. 
    Se utiliza cuando no se especifica un modificador. 

- Para atributos, métodos y constructores,
  - public El código es accesible para todas las clases 	
  - private El código sólo es accesible dentro de la clase declarada 	
  - default El código sólo es accesible en el mismo paquete. 
    Se utiliza cuando no se especifica un modificador. 
  - protected El código es accesible en el mismo paquete y en las subclases. 

Modificadores de no acceso: no controlan el nivel de acceso, pero proporcionan otras funcionalidades
- Para las clases, se puede utilizar tanto final como abstracto
  - final La clase no puede ser heredada por otras clases
  - abstract La clase no puede ser utilizada para crear objetos 
    (Para acceder a una clase abstracta, debe ser heredada de otra clase.).

- Para los atributos y métodos
  - final Los atributos y métodos no pueden ser sobrescritos/modificados
  - static Los atributos y métodos pertenecen a la clase, en lugar de a un objeto
  - abstract Sólo se puede utilizar en una clase abstracta, y sólo se puede utilizar en los métodos. 
    El método no tiene cuerpo, por ejemplo abstract void run();. 
    El cuerpo lo proporciona la subclase (heredada de). 
  - transient Los atributos y métodos transitorios se omiten al serializar el objeto que los contiene
  - synchronized Los métodos sólo pueden ser accedidos por un hilo a la vez
  - volatile El valor de un atributo no se almacena en caché localmente, y siempre se lee de la "memoria
    principal"

_JavaDevelopment/javasrc-main/src/testing/AtributoStaticPublic.java

Un método static - estático significa que se puede acceder a él sin crear un objeto de la clase, 
Un método public - publico significa que se debe acceder a él creando un objeto de la clase

Una Instancia es como crear una plantilla y definir un tipo, se pueden crear tantas entidades (instancias) como sean necesarias...y evolucionar el estado de estas de forma independiente.

Ex: Crear diferentes semáforos independientes entre sí es decir, que cada uno se encuentre en un estado diferente a los demás obligatoriamente SE DEBE instanciar.

    // Para declarar un objeto de una clase dada
    Tipo Variable;

    ex:
    Semaforo MiSemaforo; // De esta manera, creamos un apuntador capaz de direccionar 
                         // un objeto (instancia) de la clase Semaforo.java

    MiSemaforo = new Semaforo(); // Instanciamos 
          |
          V
    Semaforo MiSemaforo = new Semaforo(); // Declaramos e Instanciamos - 
                                          // Tenemos una variable "MiSemaforo", 
                                          // que direcciona un objeto creado de la clase "Semaforo".

    new Semaforo() // Son los constructores de la clase

Se pueden crear tantas instancias como sea necesario, en este caso cada una puede tener un valor diferente en un mismo instante.

// MiSemaforo direcciona un objeto creado (instanciado), de la clase Semaforo:
Semaforo MiSemaforo = new Semaforo();

MiSemaforo
    |
    V
------Semaforo.java------------------
|  Propiedad private                 |
|  -------------------------         |
|  | String EstadoSemaforo |         |
|  -------------------------         |                     Métodos public
|                              --------------------------
|                              | PonColor(String Color) | public - me permite acceder al private 
|                              --------------------------          EstadoSemaforo
|                                    |
|                              -----------------------
|                              | String DimeColor () | public
|                              -----------------------
|                                    |
--------------------------------------

Otras instancias:
Semaforo OtroSemaforo = new Semaforo();
Semaforo SemaforoDeMiCalle = new Semaforo();

Cada instancia es diferente ya que pueden tener un valor diferente en un mismo instante.

Para designar una propiedad o un método de una clase, utilizamos la notación punto:

Objeto.Propiedad
Objeto.Metodo()

Cada variable esta implementando la propiedad EstadoSemaforo.
Cada una de ellas puede contener un valor diferente.

De esta forma, si queremos poner en verde el semaforo "SemaforoDeMiCalle" , empleamos la instrucción:
// Objeto.Metodo()
SemaforoDeMiCalle.PonColor("Verde");
MiSemaforo.PonColor("Rojo");
OtroSemaforo.PonColor("Verde");

Para consulta el estado de un semaforo:

// Objeto.Metodo()
System.out.println(OtroSemaforo.DimeColor());
if(MiSemaforo.DimeColor().equals("Rojo");)
String Luz = SemaforoDeMiCalle.DimeColor();

En nuestro ejemplo NO podemos acceder directamente a la propiedad EstadoSemaforo, por ser privada.
En caso de que fuera pública se podría poner: 
// Objeto.Propiedad
String Luz = SemaforoDeMiCalle.EstadoSemaforo; 

_JavaDevelopment/testjdk_1.8.0.292/src/Semaforo.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSemaforo.java

Sobrecarga de métodos es un mecanismo muy util que permite definir en una clase varios métodos con el mismo nombre y distino número de parámetros.

Para que el compilador pueda determinar a que método nos referimos en un momento dado, los parámetros de los métodos NO PUEDEN SER IDENTICOS.

Ex: Clase para definir un objeto 3D
    Para establecer la dimensión de un objeto (anchura, profundidad, altura) en una medida dada (centimetros,pulgadas, etc), 
    Podemos definir los métodos:

    1. - Dimensiones(double Ancho, double Alto, double Profundo, String Medida)
    2. - Dimensiones(String Medida, double Ancho, double Alto, double Profundo)
    3. - Dimensiones(double Ancho, String Medida, double Alto, double Profundo)
    4. - Dimensiones(double Ancho, double Alto, String Medida, double Profundo)

    Igual número de parámetros, en diferente orden, 
    El compilador podrá determinar a cual de los métodos nos referimos por la posición de parámetro de tipo String.

    Si definimos el método: El compilador generará un error al compilar la clase

    5. - Dimensiones(double Alto, double Ancho, double Profundo, String Medida)

    El compilador NO podrá determinar a cual de los métodos nos referimos ya que existe un método (1.-) con las mismas condiciones (firma.)
    La firma, se compone del nombre del método, número de parámetros y tipo de parámetros (por orden de colocación). 
    
    métodos sobrecargados con distinto número de parámetros.

    6. - Dimensiones(String Medida)
    7. - Dimensiones(double Ancho, double Alto, double Profundo)

    Los métodos 6 y 7 son compatibles con todos pero tendrían sentido si suponemos dos métodos adicionales que los complementen:

    Dimensiones3D(double Ancho, double Alto, double Profundo)
    TipoMedida(String Medida)

_JavaDevelopment/testjdk_1.8.0.292/src/Objeto3D.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaObjeto3D.java

Constructores son métodos que nos sirven para iniciar los objetos al definirse las instancias de los mismos.
Asignan valores iniciales a las propiedades de la clase, es decir, situar a la clase instanciada en un estado concreto.
It always returns an instance of the class that it is in.

La sintaxis de los constructores en la misma que la de los métodos, salvo que no tienen la referencia del atributo de acceso y nunca devuelven ningún valor. (Tampoco se pone la palabra reservada void), además su nombre debe coincidir con el nombre de la clase.

Los constructores suelen estar sobrecargados, para permitir más posibilidades de inicilización de las instancias de las clases.

Los constructores nos permiten, a la vez, crear instancias y establecer el estado inicial de cada objeto instanciado,
a diferencia de lo que hemos realizado en el ejercicio anterior(Objeto3D.java), donde primero debiamos instanciar los objetos y posteriormente, en otras instrucciones, establecer su estado inicial.
(los métodos los convertimos en constructores cambiandoles de nombre y quitandoles los Atributos de Acceso y la palabra "void")

    1. - Objeto3DConConstructor(double Ancho, double Alto, double Profundo, String Medida)
    2. - Objeto3DConConstructor(String Medida, double Ancho, double Alto, double Profundo)
    3. - Objeto3DConConstructor(double Ancho, String Medida, double Alto, double Profundo)
    4. - Objeto3DConConstructor(double Ancho, double Alto, String Medida, double Profundo)
    6. - Objeto3DConConstructor(String Medida)
    7. - Objeto3DConConstructor(double Ancho, double Alto, double Profundo)

    // this invoca a los constructores de esta clase cuya firma coincida con la firma de las instrucciones llamantes
   
    Los métodos estáticos referencian propiedades y métodos estáticos.

No es posible hacer referencia a una propiedad de instancia o un método de instancia (o non-static methods - NECESITA UNA INSTANCIA para usarlo) desde un método estático. 
Esto es así debido a que en el momento que se ejecuta un método estático puede que no exista ninguna instancia de la clase donde se encuentra la propiedad o el método  
we would use the this keyword when you need to make a distinction between an attribute variable and a parameter.
the this allows you to access the attributes inside the class.

Estos dos métodos complementan a TODOS los DEMÁS métodos sobrecargados "Dimensiones"
    
    Dimensiones3D(double Ancho, double Alto, double Profundo) - permite asignar valores a las tres dimensiones espaciales de un objeto.
    TipoMedida(String Medida) - permite asignar un valor a la propiedad Tipo Medida.

_JavaDevelopment/testjdk_1.8.0.292/src/Objeto3DConConstructor.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaObjeto3DConConstructor.java

    // this se refiere a la clase Figura, no a la variable Posicion

_JavaDevelopment/testjdk_1.8.0.292/src/Figura.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaFigura.java

    // se rellena la matriz en forma de buffer circular (se consigue con %), 

_JavaDevelopment/testjdk_1.8.0.292/src/Telefono.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaTelefono.java

_JavaDevelopment/testjdk_1.8.0.292/src/LogisticaAlmacen.java
_JavaDevelopment/testjdk_1.8.0.292/src/LogisticaControl1Contenedor.java

--O-J-O--
El método setHacerLLamada debe arreglarse para que almacene el String pasado
debería dejarlo con String.. (intentarlo con int..  :/)
_JavaDevelopment/testjdk_1.8.0.292/src/TelefonoSC.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaTelefonoSC.java

CLASES UTILIZADAS COMO PARÁMETROS

Utilizando una clase como parámetros en un método hace posible que el método utilice toda la potencia de los objetos java, independizando las acciones realizadas de los objetos sobre las que las realiza.

Ex: escribir un método llamado ControlIgnicion
ControlIgnicion(Cohete MiVehiculoEspacial){
    realizar operaciones sobre la clase MiVehiculoEspacial de la clase Cohete
}
...
...
El mismo método podria simular el control de ignición de distintos cohetes, siempre que estos estén definidos como instancias de la clase Cohete..
------
| ...
| Cohete Pegasus, Ariane, etc;
| ...
| ...
| ControlIgnicion(Pegasus);
| ControlIgnicion(Ariane);
------
Control Entrada / Salida vehiculos aparcamientos
_JavaDevelopment/testjdk_1.8.0.292/src/Almacen.java
_JavaDevelopment/testjdk_1.8.0.292/src/Puerta.java
_JavaDevelopment/testjdk_1.8.0.292/src/Aparcamiento.java

PROPIEDADES Y METODOS DE CLASE Y DE INSTANCIA

En una clase, las propiedades y los métodos pueden definirse como:

- De instancia
- De clase

Propiedades de instancia: cada vez que se define una instancia de la clase, se crean fisicamente unas nuevas variables que contendrán los valores de dichas propiedades en la instancia creada. Es decir, cada objeto(cada instancia de una clase) contiene sus propios valores en las propiedades de instancia.
Hasta que no se crea una primera instancia de una clase, no existirá ninguna propiedad visible de la clase.

Estructura de la clase (cuando se define).
    |
    V
------Sencilla.java-------------
|                              |
|                        --------------
| PropiedadDeInstancia   |            |
|                        --------------
|                              |
--------------------------------

clase Sencilla{

    public int PropiedadDeInstancia;

}

si ahora intentamos hacer uso de la propiedad PropiedadDeInstancia a través del nombre de la clase:
class PruebaSencilla{
    public static void main(String[] args){
        Sencilla.PropiedadDeInstancia = 8;    // El objeto "Sencilla" no se ha instanciado
    }
}

al compilar javac PruebaSencilla.java
se genera el siguiente error:

PruebaSencilla.java: : error: non-static variable PropiedadDeInstancia cannot be referenced from a static context
        Sencilla.PropiedadDeInstancia = 8;
                ^
1 error

La PropiedadDeInstancia es "NO estática".
Para poder hacer uso de la propiedad se debe crear alguna instanncia de la clase.

class PruebaSencilla2{
    public static void main(String[] args){
        // En este momento existe el objeto y la propiedad
        Sencilla Instancia1 = new Sencilla();

        // Ahora si puedo utilizar la PropiedadDeInstancia de la clase Sencilla.
        Instancia1.PropiedadDeInstancia = 8;
    }
}

Estructura de la clase (instanciada 2 veces por lo que podemos acceder a la PropiedadDeInstancia).
    |
    V
------Sencilla.java-------------
|                              |
|                        --------------
| PropiedadDeInstancia   |            |   <----->
|                        --------------
|                              |
-------------------------------


                            ------Sencilla.java-------------
                            |                              |
           ------------     |                        -------------- 
Instancia1 |          | --> | PropiedadDeInstancia   |            |   <----->
           ------------     |                        --------------
                            |                              |
                            -------------------------------


                            ------Sencilla.java-------------
                            |                              |
           ------------     |                        -------------- 
Instancia2 |          | --> | PropiedadDeInstancia   |            |   <----->
           ------------     |                        --------------
                            |                              |
                            -------------------------------


_JavaDevelopment/testjdk_1.8.0.292/src/Sencilla.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSencilla.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSencilla2.java

Propiedades de clase: (static) - ver ejemplo en _JavaDevelopment/testjdk_1.8.0_292/src/ProcesaEvento.java

Una propiedad de clase (propiedad estática), se declara con el atributo static
Existe incluso si no se ha creado ninguna instacia de la clase.
Pueden ser referenciadas directamente a través del nombre de la clase sin tener que utilizar el identificador de ninguna instancia

Una variable estática (static) en Java, pertenece a la clase en que fue declarada y se inicializa solo una vez al inicio de la ejecución del programa, la característica principal de este tipo de variables es que se puede acceder directamente con el nombre de la clase sin necesidad de crear un objeto.

Estructura de la clase con una propiedad de clase static.
    |
    V
--SencillaEstatica.java---------
|                              |
|                              |
|                              |
|------------------------------|
|                        --------------
| PropiedadDeClase       |            | <-->
|                        --------------
|                              |
--------------------------------

class SencillaEstatica{
    public static int PropiedadDeClase;
}

class PruebaSencillaEstatica{
    public static void main (String[] args){
        SencillaEstatica.PropiedadDeClase = 8;
        
    }
}

Las propiedades de clase son compartidas por todas las instancias de la clase.
Al crearse una instancia de la clase, no se crean las variables estáticas de essa clase.
Las variables estáticas (de clase) existen antes de la creación de las instancias de la clase.
Existen aunque no se haya creado el objeto. "new()".

class PruebaSencillaEstatica2{
    public static void main (String[] args){
        SencillaEstatica Instancia1 = new SencillaEstatica();
        SencillaEstatica Instancia2 = new SencillaEstatica();

        // Las siguientes, hacen referencia a la misma variable 
        // (la propiedad estática "PropiedadDeClase" de la clase "SencillaEstatica".).
        SencillaEstatica.PropiedadDeClase = 4;
        Instancia1.PropiedadDeClase = 8;
        Instancia2.PropiedadDeClase = 5;
    }
}

El compilador muestra un Warning:
The static field SencillaEstatica.PropiedadDeClase should be accessed in a static wayJava(570425420)
int PropiedadDeClase
Instancia1.PropiedadDeClase = 8;
Instancia2.PropiedadDeClase = 5;

--SencillaEstatica.java---------
|                              |
|                              |
|                              |
|------------------------------|
|                        --------------                -------------------------------------
| PropiedadDeClase       |            | <------------> | SencillaEstatica.PropiedadDeClase |
|                        --------------                | Instancia1.PropiedadDeClase       |
|                              |                       | Instancia2.PropiedadDeClase       |
|                              |                       -------------------------------------
--------------------------------


                            --SencillaEstatica.java---------
           ------------     |                              |
Instancia1 |          | --> |                              |
           ------------     |                              |
                            --------------------------------

                            --SencillaEstatica.java---------
           ------------     |                              |
Instancia2 |          | --> |                              |
           ------------     |                              |
                            --------------------------------

_JavaDevelopment/testjdk_1.8.0.292/src/SencillaEstatica.java
_JavaDevelopment/testjdk_1.8.0.292/src/PruebaSencillaEstatica.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaSencillaEstatica2.java


En una clase, las propiedades y los métodos pueden definirse como 

De instancia y 
De clase

Los métodos de instancia al igual que las propiedades de instancia, 
sólo pueden ser utilizados a través de una instancia de la clase.
non-static instance variables de instancia - their values change depending on the triangle instance
(método main - estático)

-----------
| funcionamiento de los métodos de instancia:
| 
|         LogisticaAlmacen Almacen1 = new LogisticaAlmacen( (byte) 2);
|         LogisticaAlmacen Almacen2 = new LogisticaAlmacen( (byte) 4);
|         LogisticaAlmacen Almacen3 = new LogisticaAlmacen( (byte) 8);
| 
| utilización de los métodos a través del nombre de la instancia
|         if ( Almacen1.hayHueco() )
-----------

Cualquier intento de acceder a un método de instancia a través del nombre de la clase(y no de una instancia de la clase) nos dará error de compilación.

Métodos de clase: (static) -> ver otro ejemplo en _JavaDevelopment/testjdk_1.8.0_292/src/ProcesaEvento.java 
// pow() is a static method (class methods), we call them using the class name
// System.out.println, println is a class method
NO SE NECESITA UNA INSTANCIA para usarlo

Static class variables do not change per instance; they hold a value for the whole class to use
Un método estático puede ser utilizado sin necesidad de definir previamente instancias de la clase que contiene el método. Los métodos estáticos pueden referenciarse a través del nombre de la clase(al igual que las propiedades estáticas). 
Esta posibilidad es útil en diversas circunstancias:

- Cuando el método proporciona una utilidad general.
    No es necesario crear ninguna instancia del método Math.
    Math.sqrt(valor_double) --> esto es porque el método sqrt de la clase Math es estático.

- Cuando el método hace uso de propiedades estáticas u otros métodos estáticos.
    Los métodos estáticos referencian propiedades y métodos estáticos.

No es posible hacer referencia a una propiedad de instancia o un método de instancia (o non-static methods - NECESITA UNA INSTANCIA para usarlo) desde un método estático. 
Esto es así debido a que en el momento que se ejecuta un método estático puede que no exista ninguna instancia de la clase donde se encuentra la propiedad o el método de instancia al que referencia el método estático.

The main difference between an instance (non-static) method and a class (static) method:
A class (static) method is static and does not require an instance to be created first to use it.
    
testjdk_1.8.0_292/src/PruebaClassString.java


    |
    |
    V
      ----------                                              ----------
------| Clase1 |----------------                        ------| Clase2 |------------
|     ----------               |                        |     ----------           |
|                              |                        |                          |
|                        --------------                 |--------------------------|
| PropiedadDeInstancia   |            |                 |                    --------------
|                        --------------                 | MetodoEstatico     |            |------------
|                               |                       |                    --------------
--------------------------------                        |                          |          |       |
                                                        ----------------------------          |       |
                                                                                              |       |
                                              ------------------------------------------------------  |
                                              | Referencias a objetos "potencialmente" inexistente |  |
                                              ------------------------------------------------------  |
                                                                                              |       |
-----------------------------------------------------------------                             |       |
|                                                               |                             |       |
|                        --------->      ----------             |                             |       |
|                        |           ----| Clase1 |-----------  |                             |       |
|                        |           |   ----------          |  |                             |       |
|                   ------------     |                       |  | <----------------------------       |
| Instancia1Clase1  |          |     |  PropiedadDeInstancia |  |                                     |
|                   ------------     |                       |  |                                     |
|                                    -------------------------  |                                     |
|                                                               |                                     |
|                        --------->      ----------             |                                     |
|                        |           ----| Clase1 |-----------  |                                     |
|                        |           |   ----------          |  |                                     |
|                   ------------     |                       |  |                                     |
| Instancia2Clase1  |          | --> |  PropiedadDeInstancia |  | <-----------------------------------
|                   ------------     |                       |  |
|                                    -------------------------  |
|                                                               |
-----------------------------------------------------------------

Los compiladores de Java comprueban estas situaciones y generan errores cuando detectan una referencia a un objeto no estático dentro de un método estático.

// para solucionar el error se deberá definir como:
// static int valor = 8;

class Error{

    int valor = 8;

    public static void main(String[] args) {
        valor = 6;    
    }

}

_JavaDevelopment/testjdk_1.8.0_292/src/Error.java


class NoError{

    static int valor = 8;

    public static void main(String[] args) {
        valor = 6;
    }

}

_JavaDevelopment/testjdk_1.8.0_292/src/NoError.java

Ejemplo con propiedades de clase:

El control de una votación en la que se puede presentar un número cualquiera de candidatos.
En cada momento se puede votar a cualquier candidato y se pueden pedir los siguientes datos:

- Nombre de un candidato concreto y el número de votos que lleva hasta el momento
- Nombre del candidato más votado hasta el momento y número de votos que lleva conseguidos.

La clase Votacion, 
Permite almacenar el nombre de un candidato y el numero de votos que lleva, 
además de los métodos necesarios para actualizar el estado del objeto.
Si instanciamos la clase 14veces por ejemplo... 
se podrá llevar el control de votos de 14 candidatos.

¿Cómo contabilizar el número de votos y almacenar el nombre del candidato más votado hasta el momento?
- Crear una clase "MasVotado", que se instancie una sola vez y 
  contenga propiedades para almacenar estos valores,
  junto a métodos para consultarlos y actualizarlos.

Esta solución NO REQUIERE del uso de una nueva clase "MasVotado" o similar, ni necesita un número fijo de instanciaciones para funcionar. Contiene las propiedades y métodos de acceso a la persona más votada dentro de la propia clase Votacion, en la que se vota a cada persona.

Como el nombre y el número de votos de la persona más votada 
hasta el momento es una información GENERAL.- Sólo existe un espacio de almacenamiento de estas variables.
que NO depende únicamente de los votos de un candidato, 
sino de los votos recibidos por todos los candidatos, 
estas propiedades deben ser accesibles, comunes y compartidas por todos.
Estas variables deben ser estáticas (de clase).

_JavaDevelopment/testjdk_1.8.0_292/src/Votacion.java


             -----------------
-------------| Votacion.java |-----------
|            -----------------          |
|                     --------------    |
| VotosMasVotado      |            |    |                            
|                     --------------    |
|                                       |
|                     --------------    |
| PersonaMasVotada    |            |    |
|                     --------------    |
| Existen desde que se ejecuta la app   |
|                            ----------------------- 
| static                     | VotosDelMasVotado() |
| PROPIEDADES / METODOS      -----------------------
|            DE                         |
|           CLASE            ------------------------ 
|        (Generales)         | NombreDelMasVotado() |
|                            ------------------------ 
|_______________________________________|
|                                       |
|                     --------------    |
|        Votos        |            |    |
|                     --------------    |
|                                       |
|                     --------------    |
|        Persona      |            |    |
|                     --------------    |
|                                       |
|                              ----------------------- 
|                              | NombrePersona()     |
|                              ----------------------- 
| Se replican con cada Instanciación    |
|                                  -----------
|    PROPIEDADES / METODOS         | Voto () |
|               DE                 -----------
|            INSTANCIA                  |
|                                  -----------
|               new()              | Votos() |
|                                  -----------
|_______________________________________|


PAQUETES Y ATRIBUTOS DE ACCESO

Los paquetes sirven para agrupar clases relacionada, de esta manera, cada paquete contiene un conjunto de clases.
Las clases que hay dentro de un paquete deben tener nombres diferentes para que se puedan diferenciar entre sí, peor no hay ningún problema en que dos clases que pertenecen a paquetes diferentes tengan el mismo nombre; los paquetes facilitan tanto el agrupamiento de clases como la asignación de nombres.
Cuando no se especifica el nombre del paquete al que pertenece una clase, esta clase pasa a pertenecer al "paquete por defecto".

Primera sentencia de la clase:  package Nombre_Paquete;  package Terminal;

/home/hadoop/SCProjects/0_SCProjects_github.com_SCelisV/_JavaDevelopment/testjdk_1.8.0_292/src/Terminal
total 28K
Ordenador.java
Telefono.java
WebTV.java

Estas clases son accesibles desde fuera de paquete, por ser (public) publicas.

package Terminal;
public class Telefono{
    ...
    ...
}

package Terminal;
public class Ordenador{
    ...
    ...
}

package Terminal;
public class WebTV{
    ...
    ...
}

Cuando necesitamos hacer uso de todas o algunas de las clases de un paquete:
- Especificando la clase que se va a utilizar(junto con la referencia de su paquete);
    import Terminal.Ordenador;
- Se indica que se quiere hacer uso (potencialmente) de todas las clases del paquete.
    import Terminal.*;

SÓLO se pueden usar desde fuera de una paqueta las clases definidas como públicas dentro de ese paquete.

import Terminal.Ordenador;
class TerminalOficinaBancaria{
    // podemos utilizar las referencias deseadas a la clase Ordenador
    // podemos referenciar sus propiedades y métodos de manera directa
}

Estos paquetes de utilidades son tan comunes que no es necesario importarlos para usarlos
java.lang.Math
java.lang.String

Otra alternativa es no utilizar la sentencia import y referenciar los objetos con caminos absolutos:
Esto no es muy legible
Terminal.Telefono MiTelefono = new Terminal.Telefono(...); 
--O-J-O--
Actualizar el CLASSPATH con la ruta en donde almacenamos los paquetes: ejemplo en windows 
C:\Paquetes\Terminal
set CLASSPATH = C:\Paquetes\Terminal en autoexec.bat
ó 
CLASSPATH = C:\Paquetes\Terminal

javac --classpath C:\Paquetes\Terminal\TerminalOficinaBancaria.java

_JavaDevelopment/testjdk_1.8.0_292/src/TerminalOficinaBancaria.java

--O-J-O--
atributos de acceso (public) y (private) indican acceso a las propiedades y métodos de una clase desde el exterior a la misma.
Los atributos son de acceso (private) y sólo se puede acceder a ellos (en consulta o modificación) a través de métodos públicos.

----------------------------------------------------------------------------------------
|                |                   |                         | Acceso    | Acceso    |
|                |                   |                         |   desde   |  desde    |
| Tipo de acceso | Palabra reservada | Ejemplo                 | una clase | una clase |
|                |                   |                         | del MISMO | de OTRO   |
|                |                   |                         | PAQUETE   | PAQUETE   |
----------------------------------------------------------------------------------------
|  Privado       |    private        | private int Propiedad   |    NO     |     NO    |
----------------------------------------------------------------------------------------
|Sin Especificar |                   |         int Propiedad   |    SI     |     NO    | ----------------------------------------------------------------------------------------
|  Protegido     |    protected      | protected int Propiedad |    SI     |     NO    | ----------------------------------------------------------------------------------------
|  Público       |    public         | public int Propiedad    |    SI     |     SI    |
----------------------------------------------------------------------------------------

El acceso desde una clase perteneciente al MISMO PAQUETE sólo esta prohibido si el miembro es privado.
El acceso desde una clase perteneciente a OTRO PAQUETE sólo está permitido si el miembro es público:

Ex
package ConversionDeMedidas;
public class ConversionDeDistancias{
    // puede ser referenciada desde un paquete/clase (VentaDeProductos/VentaDeNaranjas)
    // por ser definida como public
    final public double LibrasAKilos = ... ;
}

package VentaDeProductos;
import ConversionDeMedidas.ConversionDeDistancias;
class VentaDeNaranjas{
    ...
    double Kilos = Libras * LibrasAKilos;
}

Los otros atributos tienen sentido en herencia.

MAQUINA EXPENDEDORA
Controlar el funcionamiento de una máquina expendedora sencilla.
Suministra botellas de agua, naranja y coca-cola
Establecer los precios de cada producto
Admite monedas de 1€, y de 10centimos(0.1€).
Definir una máquina con cualquier numero de productos
- Cuantas botellas de agua nos quedan (en el deposito de botellas de agua)
- Cuantas botellas de naranja nos quedan (en el deposito de botellas de naranja)
- Cuantas botellas de coca-cola nos quedan (en el deposito de botellas de coca-cola)
- Cuantas monedas de Euro nos quedan (en el deposito de monedas de Euro)
- Cuantas monedas de 10centimos de Euro nos quedan (en el deposito de monedas de 10centimos de Euro)
Esta clase gestionará un Almacén de elementos reutilizar Almacen.java en MaquinaAlmacen.java

    /*---------------------
    // Propiedades de Instancia
    // Esta forma es más adaptada a la programación orientada a objetos
    // Definidas como private e incorporar los métodos para 
    // obtener sus referencias
    // Algo como: --- pendiente de probar
    private MaquinaAlmacen DepositoAgua = new MaquinaAlmacen((short) 8);

    public MaquinaModeloSencillo getAlmacenAgua(){
    ó 
    public MaquinaModeloSencillo getAlmacen(String TipoAlmacen)
    */


Se podría crear nuevas clases que definieran más productos ó mejor aún
Ampliar esta clase con nuevos productos. --> ver Herencia

Las máquinas definidas o las que podamos crear siguiendo el patron de MaquinaModeloSencillo necesitan un elemento adicional, el control de las monedas.

_JavaDevelopment/testjdk_1.8.0_292/src/MaquinaAlmacen.java
_JavaDevelopment/testjdk_1.8.0_292/src/MaquinaModeloSencillo.java

_JavaDevelopment/testjdk_1.8.0_292/src/MaquinaAutomataEuros.java --> pendiente de picar y de probar el código

HERENCIA

Nos permite crear clases que especializan a otras previamente definidas.

// Publicación es la SuperClase de Libro
// Una SuperClase puede tener cualquier número de SubClases
public class Publicacion {
    private int NumeroDePaginas;
    private float Precio;
}

// Creamos un Libro especifico a partir de la clase Publicacion
// Esta clase extiende de la clase Publicación
// Contiene TODAS las propiedades de la clase Publicación
// Libro es una clase derivada o SubClase de Publicacion.

public class Libro extends Publicacion{
    public String Titulo;
    public String TipoPortada;
    public String ISBN;
    public String NombreAutor;
    public String Editorial;
}
public class Periodico extends Publicacion{
    public String Nombre;
    public String Fecha;

Un libro se define por NumeroDePaginas, Precio, Titulo, TipoPortada, etc...

// Comprobar que un libro contiene las propiedades de la SuperClase como de la SubClase:
public class PruebaLibro {

    public static void main(String[] args){
        Libro MiLibro = new Libro();
        MiLibro.Titulo = "Este libro es mi libro";
        MiLibro.TipoPortada = "Dura";
        MiLibro.ISBN = "9788478975495";
        MiLibro.NombreAutor = "Jesus Bobadilla";
        MiLibro.Editorial = "RA-MA";
        MiLibro.NumeroDePaginas = 589;
        MiLibro.Precio = 190.00f;
    }
    
}
                                     ---------------
                            -------> | Publicacion | <------
                            |        ---------------       |
                            |                              |
                        ---------                    -------------
                        | Libro |                    | Periodico |
                        ---------                    -------------

El mecanismo de herencia NO SÓLO actuá sobre las propiedades, lo hace sobre todos los miembros
(métodos y propiedades) de las clases, de esta manera las clases se pueden completar con métodos

_JavaDevelopment/testjdk_1.8.0_292/src/Publicación.java
_JavaDevelopment/testjdk_1.8.0_292/src/Libro.java
_JavaDevelopment/testjdk_1.8.0_292/src/Periodico.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaLibroPeriodico.java

Las SubClases heredan todos los miembros de su SuperClase, aunque NO todos los miembros tienen porque ser accesibles.
En particular los miembros privados de una SuperClase NO SON directamente accesibles en sus SubClases.
Los miembros protegidos de la SuperClase si son accesibles a SubClases situadas en paquetes diferentes a la SuperClase
Las propiedades de la SuperClase NO son directamente accesibles desde las SubClases Periodico y Libro
// Es mejor no usar la ocultación en el diseño de las clases.
Existe la posibilidad de "ocultar" propiedades de la SuperClase, definiendo propiedades con el mismo nombre en la SubClase.
En este caso en la SubClase, al referenciar directamente el nombre nos referimos a la propiedad de la SubClase.
Existe la posibilidad de "ocultar" métodos similar al de las propiedades y se denomina redefinición, nos permite volver a definir el comportamiento de los métodos de la SuperClase, además su atributo de acceso debe ser el mismo o menos restrictivo que el original.
para referirnos a las propiedades y a los métodos de la SuperClase tenemos que hacerlo con super.Nombre

----------------------------------------------------------------------------------------
|                |                   |                         | Acceso    | Acceso    |
|                |                   |                         |   desde   |  desde    |
| Tipo de acceso | Palabra reservada | Ejemplo                 | una clase | una clase |
|                |                   |                         | SubClase  | SubClase  |
|                |                   |                         | del MISMO | de OTRO   |
|                |                   |                         | PAQUETE   | PAQUETE   |
----------------------------------------------------------------------------------------
|  Privado       |    private        | private int Propiedad   |    NO     |     NO    |
----------------------------------------------------------------------------------------
|Sin Especificar |                   |         int Propiedad   |    SI     |     NO    | ----------------------------------------------------------------------------------------
|  Protegido     |    protected      | protected int Propiedad |    SI     |     SI    | ----------------------------------------------------------------------------------------
|  Público       |    public         | public int Propiedad    |    SI     |     SI    |
----------------------------------------------------------------------------------------

CONSTRUCTORES DE LAS SubClaseS

En las clases derivadas de una SuperClase, los constructores, además de establecer el estado inicial
de su propia SubClase deben establecer el estado inicial de la SuperClase.

Si se usa super, debe ser (obligatoriamente) la primera sentencia del constructor.
        super(parámetros) // donde puede haber cero o más parámetros

Cuando en un constructor de una SubClase no se utiliza la sentencia "super", el compilador inserta 
automáticamente super() como primera instrucción.
Esto puede dar lugar a errores de compilación, puesto que si en la SuperClase hemos definido algún constructor y no hemos definido super(), el compilador no encontrará este constructor.
Si en la SuperClase no hemos definido ningún constructor, no existirán problemas, 
puesto que super() es el constructor por defecto que crea el compilador cuando nosotros no definimos otro.

En cualquier caso, cuando se necesite, se recomienda poner explicitamente la llamada super().


 // Constructores
    // vacio o sin parámetros, se llamá automaticamente si no ponemos "super" en algun constructor
    // de una SubClase
    Publicacion2(){
        NumeroDePaginas = 2;
        Precio = 0f;
    }
    // firma int
    Publicacion2(int NumeroDePaginas){
        setNumeroDePaginas(NumeroDePaginas);
    }
    // firma float 
    Publicacion2(float Precio){
        setPrecio(Precio);
    }
    // firma int, float 
    Publicacion2(int NumeroDePaginas, float Precio){
        // Invoca al constructor de la misma clase que coincide en firma con la llamada
        // Este invoca al constructor Publicacion2(int NumeroDePaginas)
        this(NumeroDePaginas);
        setPrecio(Precio);
    }
    // firma float, int
    Publicacion2(float Precio, int NumeroDePaginas){
        // Invoca al constructor de la misma clase que coincide en firma con la llamada
        // Este invoca al constructor Publicacion2(int NumeroDePaginas, float Precio)
        this(NumeroDePaginas, Precio);
    }

No es muy habitual usar el indicador final ya que restringe la posibilidad de reutilizar las clases
usando el mecanismo de herencia.

Si utilizamos el modificador final al definir una clase evitamos que se puedan construir clases derivadas de la misma:

public final class NombreClase{
    // Contenido de la clase
}

    Constructores - 
    int NumeroDePaginas; float Precio;
    String Titulo; String TipoPortada; String ISBN; String NombreAutor; String Editorial;
    String Nombre; String Fecha;

_JavaDevelopment/testjdk_1.8.0_292/src/Publicación2.java
_JavaDevelopment/testjdk_1.8.0_292/src/Libro2.java
_JavaDevelopment/testjdk_1.8.0_292/src/Periodico2.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaLibroPeriodico2.java

    Constructores - 
    Color Color; int[] Posicion;
    double Radio;
    double[] Lados

_JavaDevelopment/testjdk_1.8.0_292/src/FiguraGeometrica.java
_JavaDevelopment/testjdk_1.8.0_292/src/Circulo.java
_JavaDevelopment/testjdk_1.8.0_292/src/Rectangulo.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaFiguraGeometrica.java

    Constructores - aquí me quedo una firma mal revisar
    Color Color; byte Ruedas; short Cilindrada; short Potencia;
    byte Ejes;
    byte Ocupantes;

// Estas clases las he escrito creando mis constructores - 
// aunque algunos estan comentados, puede que las firmas no esten correctas, 
// es mejor revisarlas con calma en otro momento

_JavaDevelopment/testjdk_1.8.0_292/src/Vehiculos.java
_JavaDevelopment/testjdk_1.8.0_292/src/Camion.java
_JavaDevelopment/testjdk_1.8.0_292/src/Motocicleta.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaVehiculos.java

herencia
Es posible heredar atributos y métodos de una clase a otra. 

    subclase (child) - la clase que hereda de otra clase
    superclase (padre) - la clase de la que se hereda

Para heredar de una clase, utilice la palabra clave extends
La subclase hereda los atributos y métodos de la superclase

_JavaDevelopment/javasrc-main/src/testing/Padre.java
_JavaDevelopment/javasrc-main/src/testing/Hijo.java
_JavaDevelopment/javasrc-main/src/testing/Herencia_test.java

¿Por qué y cuándo utilizar la "herencia"?
- Es útil para la reutilización del código: reutilizar atributos y métodos de una clase existente cuando se crea una nueva clase.

Si no quieres que otras clases hereden de una clase, define la clase como final

POLIMORFISMO
Permite que clases de diferentes tipos puedan ser referenciadas por una misma variable.
La instancia "MiFigura" de la clase FiguraGeometrica, podrá referenciar a propiedades y métodos implementados
en las clases Circulo y Rectangulo.

------------                  --------------------      
| MiFigura |-------->>> ------| FiguraGeometrica |----------
------------            |     --------------------         |
      |                 |                            --------------
      |                 |                   Miembros |            | Propiedades y Métodos
      |                 |                            --------------
      |                 |                                  |
      |                 ------------------------------------
      |
      |                       -----------
      |------------->>> ------| Circulo |-------------------
      |                 |     -----------                  |
      |                 |                            --------------
      |                 |                   Miembros |            | Propiedades y Métodos
      |                 |                            --------------
      |                 |                                  |
      |                 ------------------------------------
      |
      |                       --------------
      -------------->>> ------| Rectangulo |----------------
                        |     --------------               |
                        |                            --------------
                        |                   Miembros |            | Propiedades y Métodos
                        |                            --------------
                        |                                  |
                        ------------------------------------

Las clases Circulo y Rectangulo implementan un método llamado Perimetro que calcula el perimetro 
de la figura geométrica: Circulo => A = π*r^2, Rectangulo => Lado*Lado

------------                  --------------------      
| MiFigura |-------->>> ------| FiguraGeometrica |----------
------------            |     --------------------         |
      |                 |                            --------------
      |                 |                   Miembros |            | Propiedades y Métodos
      |                 |                            --------------
      |                 |                                  |
      |                 |                            --------------
      |                 |                  Perimetro |            | 
      |                 |                            --------------
      |                 |                                  |
      |                 ------------------------------------
      |
      |                       -----------
      |------------->>> ------| Circulo |-------------------
      |                 |     -----------                  |
      |                 |                            --------------
      |                 |                   Miembros |            | Propiedades y Métodos
      |                 |                            --------------
      |                 |                                  |
      |                 |                            --------------
      |                 |                  Perimetro |            | 
      |                 |                            --------------
      |                 |                                  |
      |                 ------------------------------------
      |
      |                       --------------
      -------------->>> ------| Rectangulo |----------------
                        |     --------------               |
                        |                            --------------
                        |                   Miembros |            | Propiedades y Métodos
                        |                            --------------
                        |                                  |
                        |                            --------------
                        |                  Perimetro |            | 
                        |                            --------------
                        |                                  |
                        ------------------------------------
La referencia MiFigura de tipo FiguraGeometrica podrá invocar al método Perimetro de la clase Circulo o 
                                                              al método Perimetro de la clase Rectangulo,
dependiendo de, si en tiempo de ejecución, está referenciando a una instancia de la clase Circulo o está referenciando a una instancia de la clase Rectangulo.

La determinación del método Perimetro que se va a invocar (el de la clae Circulo ó Rectangulo) no se realiza en la compilación sino en TIEMPO DE EJECUCIÓN, lo que hace el polimorfismo un mecanismo de programación muy potente.

Ex: 
Un editor gráfico en el que el usuario puede dibujar figuras geométricas bidimensionales tales como circulos, rectangulos, pentagonos, triangulos, etc.
Además, dentro de las opciones de la herramienta, existe un botón que que al ser pulsado nos muestra en una ventana el valor del perimetro de la figura seleccionada.

No conocemos a priori las figuras que el usuario dibujará, eso es algo que ocurre en tiempo de ejecución,
al igual que no podemos saber por adelantado de qué figura o figuras solicitará conocer el perimetro.
En un momento dado, mientras un usuario utiliza el editor gráfico, existirá una estructura de datos que
contendrá las figuras dibujadas:

----------------------      -------
| MiFigura |    |    |......|     |
----------------------      ------- 
     |        |    |            |
     |        |    |            |       -----------
     |        |    |            ----->>>| Circulo |--------------
     |        |    |                |   -----------             |
     |        |    |                ----|       -----------     |
     |        |    -------------------------->>>| Circulo |--------------
     |        |                             |   -----------             |
     |        |                             |       --------------      |
     |        ----------------------------------->>>| Rectangulo |------------
     |                                          |   --------------           |
     |                                          |                      --------------
     |                                          |            Miembros  |            |
     |                                          |                      --------------
     |                                          |                             |
     |                                          |                       --------------
     |                                          |        -------------- |            |
     ------------------------------------------>>> ------| Rectangulo |---------
                                            |            --------------        |
                                            |                            --------------
                                            |                   Miembros |            | Propiedades y Métodos
                                            |                            --------------
                                            |                                  |
                                            |                            --------------
                                            |                  Perimetro |            | 
                                            |                            --------------
                                            |                                  |
                                            ------------------------------------
El vector MiFigura contendrá referencias a objetos de tipo FiguraGeometrica
(FiguraGeometrica[]MiFigura = new Figura[100]).
Según el usuario, en tiempo de ejecución, seleccione una figura geométrica u otra se invocará a un método Perimetro u otro.

El polimorfismo ocurre cuando tenemos muchas clases que están relacionadas entre sí por herencia.
El polimorfismo utiliza los atributos y métodos heredados para realizar diferentes tareas. 
Esto nos permite realizar una misma acción de diferentes maneras.

¿Por qué y cuándo utilizar la "herencia" y el "polimorfismo"?

- Es útil para la reutilización del código: reutilizar atributos y métodos de una clase existente cuando se crea una nueva clase.

Reglas de polimorfismo: 

La invocación a un método de una SubClase debe realizarse a través de una referencia a la SuperClase; 
es decir, 
p = LaFigura.Perimetro(), esto es adecuado 
p = ElCirculo.Perimetro(). esto No es adecuado

El método llamado debe ser también un miembro de la SuperClase; en nuestro ejemplo, el método Perimetro debe existir también en la clase FiguraGeometrica.

La firma del método debe ser igual en la SuperClase que en las clases SubClases; es decir, el nombre del método y el número y tipos de sus parámetros debe ser igual en las clases FiguraGeometrica, Circulo, Rectangulo, etc.

El tipo de retorno del método (que se utilizará de forma polimórfica) debe ser igual en la SuperClase que en las SubClases.

El atributo de acceso del método no debe ser más restrictivo en las SubClases que en la SuperClase.

se crea el método Perimetro() este método calcula el perimetro de una figura - 
El método de la SuperClase Nunca se va a ejecutar, se ejecutará el código de los métodos de las SubClases.


_JavaDevelopment/testjdk_1.8.0_292/src/PolimorfismoFiguraGeometrica.java
_JavaDevelopment/testjdk_1.8.0_292/src/PolimorfismoCirculo.java
_JavaDevelopment/testjdk_1.8.0_292/src/PolimorfismoRectangulo.java

// --O-J-O-- esta clase nos muestra la forma de crear los objetos revisar con cuidadao

Dede una SuperClase NO SE TIENEN visibilidad de los miembros de las SubClases (aunque al controrio no haya problema)
Esto genera errores de compilación: MiCirculo.getRadio() y MiRectangulo.getLados()
Los métodos getRadio() y getLados() pertenece a la clase PolimorfismoCirculo y PolimorfismoRectangulo respectivamente, y 
MiCirculo y MiRectangulo son propiedades de tipo PolimorfismoFiguraGeometrica.

Para solucionar esto tenemos dos posibilidades:

// 1. Crear una instancia de la clase PolimorfismoCirculo y asignarle la referencia de MiCirculo usando Casting
// 2. Utilizar Casting sin crear explicitamente una instancia de la clase PolimorfismoCirculo.

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaPolimorfismoFiguraGeometrica.java

Otro ejemplo de polimorfismo, 

en una superclase llamada Animal que tiene un método llamado animalSound().  
Las subclases de Animals podrían ser Pigs, Cats, Dogs, Birds - 
Y también tienen su propia implementación de un sonido animal (el cerdo oinks, y el gato meows, etc.):

_JavaDevelopment/javasrc-main/src/testing/Animal.java
_JavaDevelopment/javasrc-main/src/testing/Pig.java
_JavaDevelopment/javasrc-main/src/testing/Cat.java
_JavaDevelopment/javasrc-main/src/testing/Dog.java
_JavaDevelopment/javasrc-main/src/testing/Poliformismo.java


INNER - NEST - ANIDAR - CLASES

Anidar clases (una clase dentro de otra). 
El propósito de las clases anidadas es agrupar las clases que pertenecen juntas, lo que hace que su código sea más legible y mantenible.

Para acceder a la clase interna, 
- cree un objeto de la clase externa, y luego 
- cree un objeto de la clase interna

_JavaDevelopment/javasrc-main/src/testing/ExternaClass.java
_JavaDevelopment/javasrc-main/src/testing/ExternaInterna_test.java

CLASES ABSTRACTAS E INTERFACES
Métodos abstractos.

En este ejemplo vemos como se define la clase abstracta y en ella un método abstracto.
Además definimos una subclase ("Student") que extiende y/o hereda de la clase abstracta ("Abstracto"),
esta clase debe implementar el método abstracto.

Si ejecutamos la clase Abstracto_test podemos ver como al definir el objeto, tiene tantos los atributos de su propia clase como los de la clase que hereda.

_JavaDevelopment/javasrc-main/src/testing/Abstracto.java
_JavaDevelopment/javasrc-main/src/testing/Student.java
_JavaDevelopment/javasrc-main/src/testing/Abstracto_test.java


Un método abstracto pertenece a una clase abstracta y no tiene cuerpo. 
El cuerpo lo proporciona la subclase:
Un método abstracto se declara pero no se define, no usa{}, usa la palabra abstract y termina con (;).
No se deben definir como final ya que no se prodría redefinir en las SubClases, estas tendrán este método como abstracto y nunca podrían ser instanciadas.

    Ex: declaración de un método
    public double Perimetro(){
        System.out.println("Perimetro de SuperClase NUNCA ME DEBO EJECUTAR");
        return 0d;
    }
    Ex: declaración de un método abstracto
    public abstract double Perimetro();

Un Clase es abstracta cuando al menos tiene un método abstracto:
    public abstract class ClaseAbstracta{}

Se pueden definir variables de clase abstract:
    ClaseAbstracta MiVariable;

Se pueden definir variables de clase abstract, pero NO instanciarlas;
    ClaseAbstracta MiVariable = New ClaseAbstracta();

Se puede utilizar clases abstractas como SuperClase
    public abstract class SubClaseAbstracta extend ClaseAbstracta(){
        // definir parte de los métodos abstractos
    }

    public class ClaseNoAbstracta extends SubClaseAbstracta{
        // definir TODOS los métodos abstractos que tenga la SuperClase
    }

    ClaseNoAbstracta MiInstancia = new ClaseNoAbstracta();

Se puede diseñar aplicaciones que contengan una serie de clases abstractas y codificar las mismas sin entrar en la definición de los detalles del código de los métodos. 
La App/app queda bien estructurada, definida y consistente (podemos compilarla), a partir de este punto de partida resulta mucho más sencilla la fase de implementación.

// Estas clases las he escrito usando los constructores como estan en el libro - efectos de comprensión

_JavaDevelopment/testjdk_1.8.0_292/src/AbstractaVehiculos.java
_JavaDevelopment/testjdk_1.8.0_292/src/AbstractaMotocicleta.java
_JavaDevelopment/testjdk_1.8.0_292/src/AbstractaCamion.java

Esta clase tiene un método abstracto y utiliza polimorfismo
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaAbstractaVehiculos.java

INTERFACES

Son colecciones de constantes y métodos abstractos.
Los métodos son siempre públicos y abstractos(no es necesario definirlos como tal), y 
las constantes son siempre públicas, estáticas y 
por supuesto, final (tampoco es necesario especificar sus atributos de acceso y modificadores).
Proporcionan un mecanismo de herencia múltiple que no puede ser utilizado empleando únicamente clases.

Ex: // contiene sólo constantes
public interface DatosCentroDeEstudios {
    byte NumeroDePisos = 5;
    byte NumeroDeAulas = 25;
    byte NumeroDeDespachos = 10;
    ...
    resto de constantes
}

Ex: // contiene sólo métodos
public interface CalculosCentroDeEstudios {
    short NumeroDeAprobados(float[] Notas);
    short NumeroDeSuspensos(float[] Notas);
    float NotaMedia(float[] Notas);
    float Varianza(float[] Notas);
    ...
    resto de métodos
}

Ex: // contiene constantes y métodos
public interface CentroDeEstudios {
    byte NumeroDePisos = 5;
    byte NumeroDeAulas = 25;
    byte NumeroDeDespachos = 10;
    // resto de constantes
    short NumeroDeAprobados(float[] Notas);
    short NumeroDeSuspensos(float[] Notas);
    float NotaMedia(float[] Notas);
    float Varianza(float[] Notas);
    // resto de métodos

}

Ex: // Definir una interface basada en otra. - extends.
public interface CentroDeEstudios extends DatosCentroDeEstudios{
    short NumeroDeAprobados(float[] Notas);
    short NumeroDeSuspensos(float[] Notas);
    float NotaMedia(float[] Notas);
    float Varianza(float[] Notas);
    // resto de métodos
}

Definir SuperInterfaces y SubInterfaces.
Una Interfaz puede extender simultáneamente a varios SuperInterfaces, 
lo que supone una aproximación a la posibilidad de realizar herencia múltiple.

public interface CentroDeEstudios extends DatosCentroDeEstudios, CalculosCentroDeEstudios{
    // otros posibles métodos y constantes
}

Para poder utilizar los miembros de un interfaz es necesario implementarlo en una clase,
Cuando se implementa un interfaz con una clase no abstracta debemos implementar todos y cada uno de sus métodos
Un método abstracto se declara pero no se define, no usa{}, usa la palabra abstract y termina con (;).
Es obligatorio definir todos su métodos aunque no se desarrollen
se emplea la palabra reservada implements para indicarlo:

public class CCentroDeEstudios implements CentroDeEstudios {}

_JavaDevelopment/testjdk_1.8.0_292/src/CCentroDeEstudios.java
_JavaDevelopment/testjdk_1.8.0_292/src/CalculosCentroDeEstudios.java
_JavaDevelopment/testjdk_1.8.0_292/src/CentroDeEstudios.java
_JavaDevelopment/testjdk_1.8.0_292/src/DatosCentroDeEstudios.java


      ------------ ItfImpresion                            ------------ ItfImpresion2
------| Interfaz |------------------                 ------| Interfaz |------------------
|     ------------                 |                 |     ------------                 |
|       Imprimir             --------------          |      ImprimirBonito        -------------- 
|                            |            |          |                            |            |
|                            --------------          |                            --------------
|                                  |                 |                                  |
------------------------------------                 ------------------------------------
        ^^                   ^^                                 ^^
        ||                   ||________________                 ||
        ||                                     |                ||
   --------------- ItfPositivoImpresion        |                ||
---|             |-----------------            |                ||
|  ---------------                |            |                ||
|                            --------------    |                ||
|      Imprimir              |            |    |                ||
|                            --------------    |                ||
|                                 |            |________________||
-----------------------------------                           ------------ ItfNeutro
        ^^                                              ------|          |-----------------
        ||                                              |     ------------                |
        ||                                              |                           ------------
   --------------- ItfNegativoImpresion                 |                           | Imprimir |
---|             |-----------------                     |                           ------------
|  ---------------                |                     |                                 |
|                            --------------             |                          ------------------
|      Imprimir              |            |             |                          | ImprimirBonito |
|                            --------------             |                          ------------------ |                                 |                     |                                 | -----------------------------------                     -----------------------------------

El interfaz ItfImpresion así como el interfaz ItfImpresion2, se utiliza como superinterfaz de diversas clases, al igual que una clase puede ser superclase de varias clases derivadas.

_JavaDevelopment/testjdk_1.8.0_292/src/ItfImpresion.java
_JavaDevelopment/testjdk_1.8.0_292/src/ItfImpresion2.java

Clases que implementan las interfaces: ItfPositivoImpresion, ItfNegativoImpresion e ItfNeutro.
ItfNeutro utiliza el mecanismo de herencia múltiple (implementando simultáneamente dos interfaces).

_JavaDevelopment/testjdk_1.8.0_292/src/ItfNegativoImpresion.java
_JavaDevelopment/testjdk_1.8.0_292/src/ItfPositivoImpresion.java

Clase para probae el funcionamiento de las clases
_JavaDevelopment/testjdk_1.8.0_292/src/ItfPrueba.java

// La clase ItfNeutro implementa los dos interfaces, 
// consiguiendo herencia multiple (de métodos abstractos):
_JavaDevelopment/testjdk_1.8.0_292/src/ItfNeutro.java

// se hace uso del polimorfismo
_JavaDevelopment/testjdk_1.8.0_292/src/ItfPrueba2.java

EXEPCIONES PREDEFINIDAS

// ex: división por cero, acceso a un String declarado pero no instanciado

Denominador = 
if ( Denominador != 0 ){
    Numerador = ..............
    Resultado = Numerador / Denominador;
} else
system.out.println("No se puede realizar la división por cero");


Se escribe el código que habría que ejecutar si la situación "excepcional", se produce:
    ....
    Numerador = ..............
    Denominador = ....
    Resultado = Numerador / Denominador;
    ....
Si existe excepcion,  System.out.println("No se puede realizar la división");

Este tipo de codificación es muco más fácil de entender, ya que no es necesario incluir las instrucciones condicionales que verifican si puede darse la situación de excepción. Se puede separar de esta forma la lógica del programa de las instrucciones de control de errores.

Las exepcion son objetos (clases), que se crean cuando se produce una situación extraordinaria en la ejecución del programa.
La SuperClase de Exception es Throwable.
La SuperClase de todas las excepciones es la clase Throwable.  (2 constructores y 7 métodos).
La clase Throwable tiene dos clases derivadas: Error y Excepcion.

La clase Excepcion sirve como superclase para crear excepciones de propósito especifico (adaptadas a nuestras necesidades).
Ex: Si estamos diseñando una clase que lee secuencialmente bytes en una cinta digital de datos, podemos crear la excepcion FinDeCinta que se produce cuando el dispositivo físico ha alcanzado el final de la cinta.
Ex: Implementación de una clase de envio de datos a un satélite no geoestacionario, donde convendía incluir una excepcion FueraDeCobertura que se produzca cuando el satélite se encuentre fuera del alcance de nuestra antena parabólica. 
Ex: Al escribir un driver de impresora, se puede crear una Excepcion para el FinDePapel.
Ex: Fin DeDatos en una lectura secuencial.
Existen exepciones predefinidas para el uso de ficheros de SQL, etc. 
De la subclase RuntimeException no es necesario realizar un tratamiento explicito ya que existen pocas posibilidades de recuperar situaciones anomalas de este tipo.

La clase Error sirve como superclase para crear una serie de clases derivadas ya definidas que nos informan de situaciones anormales relacionadas con errores de muy díficl recuperación producidos en el sistema. No es obligatorio tratar estas excepciones, ya que en la ejecución de una aplicación probablemente nunca se produzcan estas situaciones anormales, sin embargo, si que es obligatorio hacer un tratamiento explicito de las excepciones derivadas de la clase Exception.

Entre las clases derivadas de RuntimeException se encuentran:

ArithmeticException: Cuando ocurre una operación aritmética errónea, Ex división entre cero; con los valores reales no se produce esta excepcion.
ArrayStoreException: Intento de almacenar un valor de tipo erróneo en una matriz de objetos.
Illegal ArgumentException: Se le ha pasado un argumento ilegal o inapropiado a un método.
IndexOutOfBoundsException: Cuando algún indice(por ejemplo de array o String) esta fuera de rango.
NegativeArraySizeException: Cuando se intanta crear un array con un índicce negativo.
NullPointerException: Cuando se utiliza como apuntador una variable con valor null.

  -------------
  | Throwable |
  -------------
  | Exception |
  -------------
    IOException - Obligatorio realizar tratamiento explicito de las excepciones.
    SQLException - Obligatorio realizar tratamiento explicito de las excepciones.                             
    AWTException - Obligatorio realizar tratamiento explicito de las excepciones.
    RuntimeException - NO Obligatorio

  -------------
  | Throwable |
  -------------
    | Error |
    ---------
    AWTError - NO Obligatorio
    LinkageError - NO Obligatorio
    ThreadDeat - NO Obligatorio
    VirtualMachineError - NO Obligatorio

    Bloque de "intento" - try - Código del programa susceptible de causar cierto tipo de excepciones.
    Bloque inferior - catch(TipoDeExcepcion Identificador) - Instrucciones de control de situaciones excepcionales.

    try{
       // Instrucciones susceptibles de causar cierto ditpo de excepciones 
    } catch (TipoDeExcepcion Identificador) {
       // Instrucciones de control de situaciones excepcionales
    }

       _JavaDevelopment/testjdk_1.8.0_292/src/Excepcion1.java

    Se ejecutan las instrucciones del bloque try hasta que se produzca la situación de excepción de TipoDeExcepcion; 
    Habitualmente, no se producirá la excepción y se ejecutarán todas las instrucciones del bloque try.
    Si se produce la excepcion, se pasa a ejecutar las instrucciones del bloque catch y posteriormente, las instrucciones siguientes al bloque catch.
    Si NO se produce la excepcion, No se ejecutan las instrucciones del bloque catch.

    Si se produce más de una excepción, se puede asociar varios bloques catch a un mismo bloque try.

    try {
        // Instrucciones susceptibles de causar cierto tipo de excepciones
    } 
    catch (TipoDeExcepcion1 Identificador) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo TipoDeExcepcion1
    }
    catch (TipoDeExcepcion2 Identificador) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo TipoDeExcepcion2
    }
    catch (TipoDeExcepcionN Identificador) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo TipoDeExcepcionN
    }
    
    No se pueden poner instrucciones entre los bloques catch.
    Si ocurre una excepcion en las instruccione del bloque try, 
    se recorren en orden los bloques catch hasta que se encuentra uno con el mismo tipo 
    o un tipo que es SuperClase de la excepcion que ha llegado.
    Se ejecutan únicamente las instrucciones del bloque catch que cumple los requisitos(si alguno lo cumple).


    try {
        // Instrucciones susceptibles de causar cierto tipo de excepciones
    } 
    catch (NullPointerException e) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo NullPointerException
    }
    catch (RuntimeException e) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo RuntimeException
       // ó de una clase derivada del mismo (distinta a NullPointerException)
    }
    catch (Exception e) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo Exception
       // ó de una clase derivada del mismo (distinta a RuntimeException)
    }

    Si cambiamos el orden (en cualquiera de sus posibles combinaciones) de los bloques catch del ejemplo nos encontramos con un error de compilación, puesto que al menos un bloque catch no podra ejecutarse nunca.

    Resulta habitual utilizar varios bloques catch correspondientes a excepciones con un mismo nivel de herencia, por ejemplo con SubClases de RuntimeException:

    _JavaDevelopment/testjdk_1.8.0_292/src/Excepcion2.java

    El Bloque finally

    try {
        // Instrucciones susceptibles de causar cierto tipo de excepciones
    } 
    catch (TipoDeExcepcion1 Identificador) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo TipoDeExcepcion1
    }
    catch (TipoDeExcepcionN Identificador) {
       // Instrucciones que se deben ejecutar si ocurre la exepcion de tipo TipoDeExcepcionN
    }
    finally{
       // Se utiliza para evitar dejar ficheros abiertos, comunicaicones sin terminar, recursos bloqueados..etc
       // Instrucciones siempre se ejecutan después de las del catch seleccionado.
    }
    
    Propagación de exepciones: Normalmente dentro de un try contienen llamadas a métodos, que a su vez pueden realizar llamadas a 
    otros métodos y así sucesivamente. Cualquiera de los métodos llamados puede provocar una excepción y cualquiera de los métodos
    puede o no tratarse con bloques catch.
    Una excepcion no tratada en un bloque se propaga hacia el bloque llamante.
    Este mecanismo de propagación continúa mientras no se trate la excepción o se llegue al método de nivel superior.
    Si la excepción no se trata en el método de nivel superior, se imprime un error por consola.

    Es conveniente que si se trata una excepcion a un nivel, esta sea tratada a niveles superiores.
    Para propagar de forma explicita una excepcionse emplea la palabra throw seguida del objeto excepcion:
    Ex: al leer un fichero y escribir en otro fichero, y tenemos un error de lectura, además de tratarla en ese nivel, debemos tratarla a nivel superior de tal forma que se informe al usuario y le permita hacer un nuevo intento si lo desea.

    // el método llamante hace tratamiento de la excepcion
    try {
        // Origen. copiaFichero(destino)
    } 
    catch (IOException e) {
       // System.out.println("Error de lectura, intentelo de nuevo");
    }
    
    // después de tratar la excepcion, se propaga con throw
    public void copiaFichero(tipofichero destino){
        try {
            // código
        } 
        catch (IOException e) {
            // cerrar ficheros, etc
            throw e;
        }
    }    

El estado de las instancias de la clase Throwable se compone de:
String que sirve de mensaje indicando las caracteristicas de la excepcion y 
pila de ejecución que contiene la relación de métodos que se encuentran en ejecución en el momento en el que se produce la excepcion.

Throwable - métodos:

getMessage(): Devuelve como String el mensaje del error almacenado en este objeto (nombre y referencia de la excepcion).
printStackTrace(): Imprime por el dispositivo de salida de errores (consola), el mensaje y la pila de ejecución. Este método está sobrecargado para poder sacar el resultado por diferentes salidas: printStackTrace(PrintStream s) printStackTrace(PrintWriter s)
toString(): Devuelve como String una descripción corta del objeto.

            catch (IndexOutOfBoundsException e) { 
                System.out.println("IndexOutOfBoundsException - Indice fuera del array");
                // Imprime un mensaje acerca de la excepcion, seguido de la pila de ejecución
                // de los métodos del programa indicando la línea donde se produce la excepcion
                e.printStackTrace();
            }

_JavaDevelopment/testjdk_1.8.0_292/src/Excepcion1.java
_JavaDevelopment/testjdk_1.8.0_292/src/Excepcion2.java
_JavaDevelopment/testjdk_1.8.0_292/src/Excepcion3.java

El mecanismo de excepciones es muy lento en ejecución comparado con el uso de instrucciones condicionales.
Aunque el mecanismo de excepciones es elegante, debemos utilizarlo con prudencia: únicamente en situaciones que realmente son excepcionales.

Ex: Se debe hacer un análisis de si una exepción que definimos, se puede tratar por una excepcion ó con una instruccion condicional 
Código de barras ilegible - dependiendo de la frecuencia - con una instrucción condicional
Código de barras NO valido(corresponde a un pase caducado) - dependiendo de la frecuencia - 
Código de barras utilizado en un periodo de tiempo demasiado breve - dependiendo de la frecuencia con una excepcion
etc... 

Una excepción definida por el programador hereda de la clase Exception.
Se incluye como mínimo el constructor vacio y 
otro que contenga un String como argumento, inicializado automáticamente con el nombre de la clase (en Throwable), el texto en este constructor se añadirá al nombre de lal clase insertado por la SuperClase.

_JavaDevelopment/testjdk_1.8.0_292/src/ExcepcionPropia.java
_JavaDevelopment/testjdk_1.8.0_292/src/ExcepcionPropiaClase.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaExcepcionPropia.java

Otro ejemplo de excepciones:
Objeto Excepcion: Define la situación de error: _JavaDevelopment/testjdk_1.8.0_292/src/ExcepcionMatricula.Java

Objeto Clase que levanta la excepcion: Reconocimiento y comunicación de la situación de error, junto con la creación del objeto excepcion: _JavaDevelopment/testjdk_1.8.0_292/src/ExcepcionMatriculaValidar.java
        // tiene un método que compara una posición de un substring dado con una expresión regular [A-Za-Z], pasada por parametro al método matches
        matricula.substring(0, 1).matches("[A-Za-z]")
        expresiones regulares a partir de v1.4JDK

Objeto Clase que recoge la excepcion: Recibe la situación de error y trata de recuperar la situación: _JavaDevelopment/testjdk_1.8.0_292/src/PruebaExcepcionMatricula.java

-----------------------------                                                --------------------------------
| ExcepcionMatriculaValidar |                                                | PruebaExcepcionMatricula     |
-----------------------------------------------------------------            --------------------------------
| ...                                                           |            |                              |
| throw new ExcepcionMatricula(ExcepcionMatricula.MAL_TAMANIO); |            | try{                         |
| ...                                                           |            | ...        |                 |
| throw new ExcepcionMatricula(ExcepcionMatricula.MAL_LETRA);   |            | ...        |                 |
| ...                                                           |            | ...        |                 |
| ...                                                      <-------------------------------                 |
| ...                                                           |            | ...        |                 |
| ...                                                           |            | }          v                 |
-----------------------------------------------------------------            --------------------------------
                                                                             |                              |
                                ----------------------                       |                              |
                                | ExcepcionMatricula |                       | catch (ExcepcionMatricula e){|
                                ----------------------                       |                              |
                                |                    |                       |                              |
                                | --------------     |                       |                              |
                                | | MalFormada |     |               ----------->...........                |
                                | --------------     |               |       | ............                 |
                                |       |            |               |       | ............                 |
                                |       |      ---------------       |       | ............                 |
                                |       ------>| getProblema | ------        |                              |
                                |              ---------------               | }                            |
                                |                    |                       --------------------------------
                                ----------------------                       

INTERFAZ GRÁFICO DE USUARIO

GUI que se encuentran englobados dentro de Java Foundation Classes (JFC), que proporciona:
    AWT: Abstract Window Toolkit proporciona los componentes básicos de I/O. 
    Swing: Recoge la mayor parte de la funcionalidad de AWT.
    Imgenes 2D
    Servicio de Impresión
    Soporte para funciones Drag-and-Drop 
    Funciones de accesibilidad
    etc.


    AWT: Abstract Window Toolkit proporciona los componentes básicos de I/O. 
    Proporciona entre otras:
    la clase Window.
    la clase Frame derivada de Window.

    Jerarquía:

    ----------
    | Object |              java.lang
    ----------
        |            ---
    -------------      |
    | Component |      |
    -------------      |
        |              |
    -------------      |
    | Container |      |
    -------------      |
        |              |--------java.awt
    ----------         |
    | Window |         |
    ----------         |
        |              |
    ---------          |
    | Frame |          |
    ---------          |
        |---------------
    ---------
    | JFrame |               javax.swing
    ---------

Todos los objetos tienen a Object como la SuperClase
La clase abstracta Component proporciona una representación gráfica susceptible a ser representada en un dispositivo de salida, se usa a través de las subclases.
Container deriva de Component y añade la funcionalidad de poder contener otros componentes AWT (por ejemplo varios botones, cajas de texto, etc.)
Window proporciona una ventana gráfica sin bordes ni posibilidad de incluir barras de menú.
Frame es derivada de window pero no presenta las restricciones de Window (puedo incluir barras de menu)
JFrame es la version de Frame Proporcionada por swing. (es más compleja para usar), proporciona mayor funcionalidad que sus superclases de AWT.

https://docs.oracle.com/javase/8/docs/api/index.html?java/awt/Frame.html
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassFrame.java
_JavaDevelopment/testjdk_1.8.0_292/src/MyFrame.java
_JavaDevelopment/testjdk_1.8.0_292/src/MyFrame1.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaMyFrame.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaMyFrame1.java

Posicionamiento de múltiples Ventanas, setLocation, heredado de Component.
Sobrecargado y admite dos tipos de parámetros de entrada: es necesario suministrar las coordenadas bidimensionales.
    estas situan la esquina superior izquierda de la ventana respecto a su componente padre
    public void setLocation(int x, int y)
    public void setLocation(Point p)

        UnFrame.setLocation(new Point(100, 200));

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPoint.java
_JavaDevelopment/testjdk_1.8.0_292/src/MyFramePoint.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaMyFramePoint.java

        PANELES Y OBJETOS DE DISPOSICION
        LAYOUTS


    AWT: Abstract Window Toolkit proporciona los componentes básicos de I/O. 
    Proporciona entre otras:
    la clase Window.
    la clase Frame derivada de Window.

    Jerarquía:
               ----------
               | Object |                                   java.lang
               ----------
                   |            --------------------
             -------------                          |
             | Component |                          |
             -------------                          |
          _________|__________                      |
         |                    |                     |
    ----------          -------------               |
    | Button |          | Container |               |
    ----------          -------------               |
                         ______|_____               |
                        |            |              |--------java.awt
                    ---------    ----------         |
                    | Panel |    | Window |         |
                    ---------    ----------         |
                                     |              |
                                 ---------          |
                                 | Frame |          |
                                 ---------          |
                                     |---------------
                                 ---------
                                 | JFrame |               javax.swing
                                 ---------

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassButton.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassButtonPanel.java

Utilización básica de PANELES

 - Flexibilidad Diseño GUI's -

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanel.java

Cada Panel que creamos tiene asociado, implicita o explicitamente un tipo de disposicion ("layout")
Layouts (default FlowLayout, BorderLayout, GridLayout)

default FlowLayout, con los elementos centrados en el panel.
BorderLayout, 
GridLayout, 

Para establecer una disposición de manera explicita, podemos recurrir al método setLayout(heredado de Container).
Instanciar nuestro panel indicando directamente el layout deseado.

    Panel MiPanel = new Panel (new FlowLayout());
    OtroPanel.setLayout(new FlowLayout());

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelFlowLayout.java

        FlowLayout PosicionamientoSecuencial = new FlowLayout();
        PnlPal.setLayout(PosicionamientoSecuencial);

        FlowLayout PosicionamientoLEFT = new FlowLayout(FlowLayout.LEFT);
        PnlPal.setLayout(PosicionamientoLEFT);

        FlowLayout PosicionamientoRIGHT = new FlowLayout(FlowLayout.RIGHT);
        PnlPal.setLayout(PosicionamientoRIGHT);

        FlowLayout PosicionamientoCENTER = new FlowLayout(FlowLayout.CENTER);
        PnlPal.setLayout(PosicionamientoCENTER);

        FlowLayout PosicionamientoLEADING = new FlowLayout(FlowLayout.LEADING);
        PnlPal.setLayout(PosicionamientoLEADING);

        FlowLayout PosicionamientoTRAILING = new FlowLayout(FlowLayout.TRAILING);
        PnlPal.setLayout(PosicionamientoTRAILING);

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelBorderLayout.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelBorderLayout2.java

 El BorderLayout situa y dimensiona los componentes en 5 regiones cardinales:
 - NORTE (BorderLayout.NORTH)
 - SUR (BorderLayout.SOUTH)
 - Occidente - OESTE (BorderLayout.WEST)
 - Oriente - ESTE (BorderLayout.EAST)
 - CENTER derecho (BorderLayout.CENTER)

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelGridLayout.java

 crea un componente matricial de n filas y n columnas

       // Crear n Botones; n=6
        Button[] Botones = new Button[6];
        for(int i=0;i<Botones.length; i++){
            Botones[i] = new Button("Botón: " + i);
        }

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelGridLayout2.java

        // Crear n Botones; n=6 y Asigna los Botones al Frame
        Button[] Botones = new Button[6];
        for(int i=0;i<Botones.length; i++){
            MyFrame.add(new Button("Botón" + i));
        }

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassPanelGridLayout3.java

       ETIQUETAS, CAMPOS Y ÁREAS DE TEXTO

    AWT: Abstract Window Toolkit proporciona los componentes básicos de I/O. 
    Proporciona entre otras:
    la clase Window.
    la clase Frame derivada de Window.

    Jerarquía:
                                   ----------
                                   | Object |                                   java.lang
                                   ----------
                                       |            --------------------
                                 -------------                          |
                    -------------| Component |                          |
                    |            -------------                          |
                    |         _________|__________                      |
                    |        |                    |                     |
                    |   ----------          -------------               |
                    |---| Button |          | Container |               |
                    |   ----------          -------------               |
                    |  ---------             ______|_____               |
                    |--| Label |            |            |              |--------java.awt
                    |  ---------        ---------    ----------         |
              -----------------         | Panel |    | Window |         |
              | TextComponent |         ---------    ----------         |
              -----------------                          |              |
                ______|_____                             |              |
               |            |                            |              |
         ------------- ------------                  ---------          |
         | TextField | | TextArea |                  | Frame |          |
         ------------- ------------                  ---------          |
                                                         |---------------
                                                     ---------
                                                     | JFrame |               javax.swing
                                                     ---------


_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassLabel.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassLabel2.java

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassTextField.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassTextField2.java

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassTextArea.java

Font son clases que heredan de forma direta de Object.

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassFont.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassFontColor.java


CAJAS DE VERIFICACION, BOTONOES DE RADIO Y LISTAS

Checkbox, CheckboxGroup, List, Choice

    Jerarquía:
                                   ----------
                                   | Object |                                                   java.lang             
                                   ----------
                                       |                                      ------------- 
            --------             -------------             -----------------              |
            | Font |-------------| Component |-------------| CheckboxGroup |              |     
            --------             -------------             -----------------              |
                                       |                                                  |-----java.awt
         ---------- --------- ----------------- ------------ -------- ----------          |
         | Button | | Label | | TextComponent | | Checkbox | | List | | Choice |          |
         ---------- --------- ----------------- ------------ -------- ----------          |
                                ______|_____                                              |
                               |            |                                             |
                         ------------- ------------                                       |
                         | TextField | | TextArea |                           -------------
                         ------------- ------------                                       

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassCheckbox.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassCheckboxGroup.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassCheckboxGroupFontColor.java

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassList.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassListMultiple.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassListChoiceDesplegable.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassListChoiceDesplegable2.java

                            --------------
                            | Formulario |
                        --------------------------------
                        |    PnlFormulario             |           
                        |    PnlDatosPersonales        |          
                        |    PnlEstadoCivil            |          
                        |    PnlCiudades               |          
                        --------------------------------
                        | DatosPersonales(Panel)       |          
                        | EstadoCivil(Panel)           |          
                        | Ciudades(Panel)              |          
                        --------------------------------
                        | Main                         |     
                        --------------------------------     

_JavaDevelopment/testjdk_1.8.0_292/src/Formulario.java

Implementación en varias clases

 -----------------------------     -------------------------      -----------------------
 | FormularioDatosPersonales |     | FormularioEstadoCivil |      | FormularioProvincia |
 -----------------------------     -------------------------      -----------------------
        |      |                        ______|_____                    |     |
        |      |                       |            |                   |     |
        |      |            ------------------ ------------------       |     |
        |      -------------| FormularioMain | | FormularioMain |--------     |
        |                   ------------------ ------------------             |
        |                           |                   |                     |
        |                           |                   |                     |
        |                           --------------------|----------------------
        |                                               |
        -------------------------------------------------

    Con mis constructores... (un poco regular definidos.. review)
    _JavaDevelopment/testjdk_1.8.0_292/src/FormularioMain.java
    _JavaDevelopment/testjdk_1.8.0_292/src/FormularioCiudades.java
    _JavaDevelopment/testjdk_1.8.0_292/src/FormularioDatosPersonales.java
    _JavaDevelopment/testjdk_1.8.0_292/src/FormularioEstadoCivil.java
    _JavaDevelopment/testjdk_1.8.0_292/src/FormularioMain2.java

             -------------------
-------------| Formulario2Main |---------------------------------------------------------------------------
|            -------------------                                                                          |
|                                       ---------------                                                   |
|                          -------------|             |                                                   |
|                          |     I      ---------------                                                   |
|                      --------                                                                           |
|   MiFrame            |      |                                                                           |
|                      --------                                                                           |
|                                       ---------------                                                   |
|                          -------------|             |                                                   |
|                          |     I      ---------------                                                   |
|                      --------                                                                           |
|   Formulario         |      |                                                                           |
|                      --------                                                                           |
|                                                                                                         |
|                                                ------------------------------                           |
|                                   -------------| Formulario2DatosPersonales |----------                 |
|                                   |             ------------------------------        |                 |
|                                   |     I           |      ----------------           |                 |
|                      --------     |                 |      |              |           |                 |
|   DatosPersonales    |      | -----------------------      ----------------           |                 |
|                      --------     | PnlDatosPersonales          |     ---------------------------       |       
|                                   |                             ---->>| getPnlDatosPersonales() |--->>  |
|                                   |                                   ---------------------------       |       
|                                   |                                                   |                 |
|                                   -----------------------------------------------------                 |
|                                                ------------------------------                           |
|                                   -------------| Formulario2EstadoCivil     |----------                 |
|                                   |             ------------------------------        |                 |
|                                   |     I           |      ----------------           |                 |
|                      --------     | PnlEstadoCivil  |      |              |           |                 |
|   EstadoCivil        |      | -----------------------      ----------------           |                 |
|                      --------     |                             |     ---------------------------       |       
|                                   |                             ---->>| getPnlEstadoCivil()     |--->>  |
|                                   |                                   ---------------------------       |       
|                                   |                                                   |                 |
|                                   -----------------------------------------------------                 |
|                                                ------------------------------                           |
|                                   -------------| Formulario2Ciudades        |----------                 |
|                                   |             ------------------------------        |                 |
|                                   |     I           |      ----------------           |                 |
|                      --------     | PnlCiudades     |      |              |           |                 |
|   Ciudades           |      | -----------------------      ----------------           |                 |
|                      --------     |                             |     ---------------------------       |       
|                                   |                             ---->>| getPnlCiudades()        |--->>  |
|                                   |                                   ---------------------------       |       
|                                   |                                                   |                 |
|                                   -----------------------------------------------------                 |
|                                                                                                         |
-----------------------------------------------------------------------------------------------------------

_JavaDevelopment/testjdk_1.8.0_292/src/Formulario2Main.java
_JavaDevelopment/testjdk_1.8.0_292/src/Formulario2Ciudades.java
_JavaDevelopment/testjdk_1.8.0_292/src/Formulario2DatosPersonales.java
_JavaDevelopment/testjdk_1.8.0_292/src/Formulario2EstadoCivil.java

Otra forma de organizar (modificando los paneles.. ) y utilizando las mismas clases predefinidas
_JavaDevelopment/testjdk_1.8.0_292/src/Formulario2Main2.java

DIALOGOS Y MENUS

Clases
Dialog y FileDialog
MenuBar y Menu

  Jerarquía:
                                   ----------
                                   | Object |                                   java.lang
                                   ----------
                                       |            --------------------
                              _________|__________                      |
                             |                    |                     |
                   -----------------        -------------               |
                   | MenuComponent |--------| Component |               |
                   -----------------        -------------               |
                  _________|__________            |                     |
                 |                    |           |                     |
           ------------          ------------     |                     |
           | MenuItem |          | MenuBar  |     |                     |
           ------------          ------------     |                     |
                 |                                |                     |
            -----------                     -------------               |
            |  Menu   |                     | Container |               |
            -----------                     -------------               |
                                             ______|_____               |
                                            |            |              |--------java.awt
                                        ---------    ----------         |
                                        | Panel |    | Window |         |
                                        ---------    ----------         |
                                                         |              |
                                                     ----------         |
                                                     | Dialog |         |
                                                     ----------         |
                                                         |              |
                                                  --------------        |
                                                  | FileDialog |        |
                                                  --------------        |

Dialog, ventana para recoger información del usuario; su disposición por defecto es BorderLayout. 
Propietario de dialogo frame ó diálogo
Modales ó
No Modales (default) - Bloquean las demás ventanas de la aplicación (salvo las que se hayan cerrado por el propio dialogo)

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassDialog.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassDialog2.java

Dialogo de carga / almacenamiento de ficheros (FileDialog), clase especializada de Dialog, gestiona la selección de un fichero entre los sistemas de ficheros accesibles.
Los dialogos de ficheros son modales y sus propietarios deben ser Frames.

Cargar Load
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassFileDialog2.java
Guardar Save
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassFileDialog.java

MenuBar se usa para dotar de una barra principal de menú a un frame.
sólo tiene el constructor sin argumentos.
setMenuBar es un método de Frame para adicionar un menú a un frame.
Una vez que disponemos de un objeto barra de menú, añadimos menús (add), 

_JavaDevelopment/testjdk_1.8.0_292/src/MenuBarMenu.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassMenuBarMenu.java

EVENTOS

Java proporciona mecanismos adecuados para tratar situaciones que habitualmente se producen de manera asíncrona a la ejecución del programa, producidas desde el exterior de la aplicación.
Más comunes en la ejecución de una app que proporciona una GUI son:
- Pulsación de ratón, se situa en un componente gráfico, , sale de un componente gráfico
- Pulsación de una tecla
- Se cierra una ventana... etc

- usuario interactua con la app por medio de dispositivos de I/O. teclado, ratón, etc.
- los dispositivos de I/O generan señales eléctrica que son recogidas por los controladores (placas, puertos, etc).
- los drivers(manejadores), de cada dispositivo recogen las señales eléctricas, las codifican y traspasan ea la CP. activan pines de interrupción excepción de la CPU.
- La CPU habitualmente deja de ejecutar la acción en curso(salvo que esta acción tenga mayor prioridad que la asociada a la interuupción que le llega) y ejecuta la rutina de tratamiento que le asigna el SO.
- El SO determina si tiene que tratar la o si tiene que pasarla a alguna aplicación que se ejecuta sobre él. En este caso a la JVM.
- La JVM determina el componente sobre el que se produce la interrupción y consulta si se ha definido alguna acción. si no hay nada definido, la CPU continua con la accion que estaba antes de la interrupción.
- Si se ha definido: 
- la JVM crea un objeto evento con la información de la acción, 
- se pasa el evento a la clase que tratara la interrupción
- se pasa el flujo de control(de ejecución) a la clase Java que hemos creado para tratar la interrupción
- se pasa el flujo de control a la CPU para que continúe con la acción que estaba antes de la interrupción

La JVM recoge la información de la interrupción del SO , determina la ventana y el componente, donde se ha producido el evento y ejecuta la acción asociada al tipo de evento que llega.

Por lo tanto: 

1. necesitamos clases que definan las posibles acciones a realizar cuando llegan los diferentes tipos de eventos.
2. No es necesario definir acciones para todos los eventos ni para todos los objetos.
3. necesitamos un mecanismo para asociar acciones a los distintos eventos que se puedan producir sonbre cada componente de nuestra GUI.

Java proporciona una serie de Interfaces que agrupan métodos relacionados para el tratamiento de eventos.
Los interfaces más comunes, normalmente relacionados con GUI's basados en AWT se encuentran en el paquete java.awt.event

El mecanismo básico de eventos de Java se basa en la existencia de las clases de eventos y los interfases "listeners", son interfaces que debemos implementar, colocando las acciones deseadas en sus métodos, también podemos basarnos en las implementaciones con métodos vacios que proporciona el SDK (adaptadores).
AWT proporciona una ámplia gama de eventos que pueden ser recogidos por los métodos existentes en las implementaciones que hagamos de los listeners.

Ex: Eventos, Interfaces y adaptadores más utilizados en app de catácter general.

            Eventos                    Interfaces                 Adaptadores
            ----------              ---------------             
 --------- | AWTEvent | ---------- | EventListener |            java.awt.event
|           ----------              ---------------             
|                                   ---------------              --------------
|           ----------       ______| MouseListener | ---------- | MouseAdapter |
|          | Mouse    |_____|       ---------------              --------------
|          |   Event  |     |______ ---------------------        -------------------
|           ----------             | MouseMotionListener | ---- | MouseMotinAdapter |
|                                   ---------------------        -------------------
|           ----------              ---------------              --------------
|--------- | KeyEvent | ---------- | Key  Listener | ---------- | Key  Adapter |
|           ----------              ---------------              --------------
|           -------------           ----------------             ---------------
|--------- | WindowEvent |-------- | WindowListener | ----------| WindowAdapter |
|           -------------           ----------------             ---------------
|           -------------           ----------------
|--------- | ActionEvent | --------| ActionListener |
|           -------------           ----------------
|           -----------             --------------
 --------- | ItemEvent | ----------| ItemListener |
            -----------             --------------

Ex: MouseListener
https://docs.oracle.com/javase/8/docs/api/java/awt/event/MouseListener.html
y KeyListener
https://docs.oracle.com/javase/7/docs/api/java/awt/event/KeyListener.html

tiene los siguientes métodos:


void 	mousePressed(MouseEvent e)  -> Se invoca cuando el botón del ratón ha sido pulsado en un componente.
void 	mouseReleased(MouseEvent e) -> Se invoca en la acción contraria

void 	mouseClicked(MouseEvent e)  -> Se invoca cuando se han producido las dos acciones consecutivas (pulsar y soltar).

void 	mouseEntered(MouseEvent e)  -> Se invoca al entrar de un componente con el puntero del ratón - focus
void 	mouseExited(MouseEvent e)   -> Se invoca al salir  de un componente con el puntero del ratón - blur

Si queremos que un texto se ponga de color rojo al situarnos sobre él componente y de color azul al salir del mismo.
Crearemos una clase que implemente los métodos mouseEntered y mouseExited respectivamente; con el interface MouseListener el compilador puede detectar errores de tipo sintactico mientras que extendiendo el MouseAdapter aunque es más comodo, es menos seguro, y el compilador no detectara errores sintactacticos al definir un método.

Los objetos de tipo evento, ex: MouseEvent, nos permiten consultar información relativa a la interrupción que genera el evento.
nos permite conocer información que proviene del SO y de la JVM.
MouseEvent
https://docs.oracle.com/javase/8/docs/api/java/awt/event/MouseEvent.html
y KeyEvent
https://docs.oracle.com/javase/7/docs/api/java/awt/event/KeyEvent.html


Nos proporciona entre otra info: el botón que se ha pulsado, las coordenadas X e Y en pix en las que se encontraba el puntero del ratón respecto al componente que ha generado la interrupción(el evento), el componente que ha generado la interrupción, etc.

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerMouse.java

Podemos implementar tantas clases "listeners" como comportamientos diferentes deseemos y asignar diferentes componentes a distintos listeners.

Un componente no tiene por que estar limitado a la funcionalidad de un sólo listener, por ejemplo pordemos hacer que un componentes se pueda seleccionar con ratón(MouseListener) o con teclado(KeyListener)

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerKey.java

Esta clase prueba las dos clases ListenerMouse.java y ListenerKey.java

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerMouseKey.java

Eventos "más usados" del raton:
----------------------------------------------------------------------------
| INTERFACE              | Adaptadores               | Evento              |
----------------------------------------------------------------------------
| MouseListener          | MouseAdapter              | MouseEvent          |
----------------------------------------------------------------------------
| métodos                |                           | métodos             |
| mouseClicked           |                           | int getClickCount() |
| mouseEntered           |                           | Point getPoint()    |
| mouseExited            |                           | int getX()          |
| mousePressed           |                           | int getY()          |
| mouseReleased          |                           | Object getSource()  |
|                        |                           | int getButton()     |
----------------------------------------------------------------------------
| MouseMotionListener    | MouseMotionAdapter        | MouseEvent          |
----------------------------------------------------------------------------
| métodos                |                           | métodos             |
| mouseDragged           |                           | int getClickCount() |
| mouseMoved             |                           | Point getPoint()    |
|                        |                           | int getX()          |
|                        |                           | int getY()          |
|                        |                           | Object getSource()  |
|                        |                           | int getButton()     |
----------------------------------------------------------------------------
| MouseWheelListener     | No tiene adaptador        | MouseWheelEvent     |
----------------------------------------------------------------------------
| métodos                |                           |                     |
| mouseWheel             |                           |                     |
----------------------------------------------------------------------------

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosMouse.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouse.java

La clase _JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosMouse.java puede ser utilizada por otras app
En este caso sobre un panel:
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouse2.java

La clase _JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosMouseObject.java
Utiliza algunos métodos de MouseEvent
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouseObject.java

Java proporciona el adaptador MouseAdapter, que implementa todos los métodos del interfaz MouseListener de esta manera, 
si usamos MouseAdapter, podemos sobrecargar únicamente los métodos que deseemos.
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosMouseAdapter.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouseAdapter.java
cuando ejecutamos la clase con este método: public void mouseEited(MouseEvent e){
no se ejecuta evento Exited del Mouse ya que el compilador no detecta el error sintactico
cuando ejecutamos la clase con este método: public void mouseExited(MouseEvent e){
se ejecuta el evento mouseExited.

Ex: en Estas clases: 
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosMouseAdapter2.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouseAdapter2.java
Se extiende de MouseAdapter, 
se crea un constructor a través del cual se puede indicar una etiqueta donde los métodos de la clase podrán asignar diferentes textos.
La etiqueta no debería ser visible en la clase ListenerEventosMouseAdapter2.java. 
Deberá unirse en un sólo fichero ambas clases, (aunque es menos modular y reutilizable)
Java proporciona medios de mayor complejidad para establecer una solución más elegante a esta interacción GUI/Adaptador aunque no se usan mucho.

Los eventos de movimiento de ratón. (mouseMoved, mouseDragged)
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerMouseMotion.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerMouseMotion.java

Se crea un constructor que contiene como parámetros dos etiquetas
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerMouseMotion2.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerMouseMotion2.java

Si queremos evitar el constructor con parámetros unificar el GUI y el adaptador en un sólo fichero
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosMouseMotion.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaEventosMouseMotion.java


EVENTOS DE TECLADO Y DE VENTANA

----------------------------------------------------------------------------
| INTERFACE              | Adaptadores               | Evento              |
----------------------------------------------------------------------------
| KeyListener            | KeyAdapter                | KeyEvent            |
| métodos                |                           | métodos             |
| keyPressed             |                           | char getKeyChar()   |
| keyReleased            |                           | int getKeyCode()    |
| keyTyped               |                           | String getKeyText() |
|                        |                           | Object getSource()  |
----------------------------------------------------------------------------
| WindowListener         | WindowAdapter             | WindowEvent         |
| métodos                |                           | métodos             |
| windowActivated        |                           | getWindow()         |
| windowDeactivated      |                           | getOppositeWindow() |
| windowOpened           |                           | getNewState()       |
| windowClosing          |                           | getOldState()       |
| windowClosed           |                           | getSource()         |
| windowIconified        |                           |                     |
| windowDeiconified      |                           |                     |
----------------------------------------------------------------------------

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosKey.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosKey.java

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerEventosKeyAdapter.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerEventosKeyAdapter.java

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerWindow.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerWindow.java

EVENTOS DE ACCIÓN, ENFOQUE Y ELEMENTO
Estos eventos tienne un nivel de abstraccción superior a los de ratón y teclado; en estos tres casos el evento se produce cuando ocurre 
una acción sobre un componente, independientemente de la causa fisica que produce ese evento.
ex: pulsar un botón haciendo uso del ratón, del teclado, e incluso por programa.
El interfaz actionlistener proporciona un método que se activa con independencia de la causa física ó lǵica que activa el componente.

------------------------------------------------------------------------------
| INTERFACE              | Adaptadores               | Evento                |
------------------------------------------------------------------------------
| ActionListener         |                           | ActionEvent           |
| métodos                |                           | métodos               |
| actionPerformed        |                           | getActionCommand()    |
|                        |                           | getWhen()             |
|                        |                           | getSource()           |
------------------------------------------------------------------------------
| FocusListener          | FocusAdapter              | FocusEvent            |
| métodos                |                           | métodos               |
| focusGained            |                           | getOppositeComponent()|
| focusLost              |                           | getID()               |
|                        |                           | getSource()           |
------------------------------------------------------------------------------
| ItemListener           |                           | ItemEvent             |
| métodos                |                           | métodos               |
| itemStateChanged       |                           | getStateChange()      |
|                        |                           | getItem()             |
|                        |                           | getItemSelectable()   |
|                        |                           | getSource()           |
------------------------------------------------------------------------------

Eventos de ACCIÓN
ActionListener y ActionEvent

Tratamiento de eventos de acción
Escribe por consola información del evento cada vez que se activa actionPerformed (método de ActionListener)

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerAction.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerAction.java

    //Constructor que recibe un panel como parámetro - Cambia el color del panel
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerAction2.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerAction2.java

Eventos de ENFOQUE - focusGained - focusLost
FocusListener, FocusEvent, FocusAdapter

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerFocus.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerFocus.java

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerFocusAdapter.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerFocusAdapter.java


Eventos de ELEMENTO - itemStateChanged - cambio de estado 
ItemListener e ItemEvent

_JavaDevelopment/testjdk_1.8.0_292/src/ListenerItem.java
        // getStateChange - newState: 1 => Seleccionado
        // getStateChange - newState: 2 => No Seleccionado

        // getState - bState: true => Seleccionado
        // getState - bState: false => No Seleccionado

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerItem.java


Opciones y validaciones interactiva, Checkbox, List(lista), Choice (lista desplegable)
// constructor que recoge un vector de componentes con el fin de actuar sobre los mismos.
_JavaDevelopment/testjdk_1.8.0_292/src/ListenerItem2.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaListenerItem2.java

Calculadora
Implementar una app que ofrezca el interfaz y el comportamiento de una calculadora sencilla.

Nuestra calculadora contendrá:
10 dígitos 0-9, 
punto decimal(.), 
signo igual (=), 
operadores (+, -, *, /,) 
espacio para visualizar las pulsaciones del usuario y los resultados obtenidos

Interfaz GUI:
---------------------------
|  _____________________  |
| |                     | |
| |_____________________| |
---------------------------
| ----- ----- ----- ----- |
| | 0 | | 1 | | 2 | | + | |     -> 0*3+0;   0*3+1;    0*3+2;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 3 | | 4 | | 5 | | - | |     -> 1*3+0;   1*3+1;    1*3+2;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 6 | | 7 | | 8 | | * | |     -> 2*3+0;   2*3+1;    2*3+2;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 9 | | . | | = | | / | |     ->     9;       .;        =;
| ----- ----- ----- ----- |
---------------------------
El comportamiento será:

--------------      --------------      --------------      --------------      -------------
| Introducir |--->> | Introducir |--->> | Introducir |--->> | Introducir |--->> |  Obtener  |
| Operando 1 |      |  OPERADOR  |      | Operando 2 |      |    SIGNO   |      | Resultado |
--------------      --------------      --------------      --------------      -------------
                           ^                                                           |
                           |___________________________________________________________|

5 * 3 = 15 / 3 = 5 * 2 = 10

Los operandos podrán ser valores númericos enteros o decimales con signo.

Un operando:

                     -----
                -----| - |----
                |    -----   |
Operando -------|            |
                |    ----------         -----      ----------
                -----| Digito |---------| . |------| Digito |
                     ----------         -----      ----------
                      |____| |                      |____| |
                             |                             |                                
                             -----------------------------------------

Diseñada según principios básicos de la PPO.
Botones con diferentes colores
Compotamiento para todos los botones:
// tanto con el ratón como con el teclado:
focusGained --> cambia de color
focusLost -->  color original.
Al pulsar una opción no valida (ex: dígito después del igual, dos operadores seguidos, etc), debe mostrar una indicación de error en el área de resultados y el botón pulsado de color rojo.


Definición de Interfaz gráfico:  - MVC - ModeloVC
Dígitos: Panel con botones que representan los dígitos del 0-9, signo(.), signo(=)
Operadores: Panel con cuatro botones de signos (+, -, *, /)
Resultados: Visor de la calculadora

Utilizando las clases: Dígitos, Operadores y Resultados, podemos definir diferentes representaciones de calculadoras.

            -------------------
            | GUICalculadora2 |             GUICalculadora?, necesitan tener acceso a los botones individuales
            -------------------
             |       |       |
         -------------------------
         |    GUICalculadora1    |
         -------------------------
             |       |        |
             | -------------- |
             | | Operadores | |             Operadores, botones individuales (+,-,*,/)
             | -------------- |
         -----------          |
         | Digitos |          |             Digitos, botones individuales (0-9,.,=)
         -----------          |
                         --------------
                         | Resultados |     Visor de la calculadora
                         --------------

    GUICalculadora?, necesitan tener acceso a los botones individuales, 
    que se definen en Digitos y Operadores, 
    de esta manera se podrá asignar diferentes objetos de tratamiento de eventos a los botones.

    Digitos, proporciona su panel con la estructura de botones individuales (0-9,.,=)
    Operadores, proporciona su panel con la estructura de botones individuales (+,-,*,/)

    Para que los botones de cada panel presente el color deseado, se proporcionará un constructor que admite un parámetro de tipo Color.

    Resultados, proporciona un campo de texto deshabilitado que hará las veces de visor de la calculadora.

    Diseño de clases: - MVC - MVistaC

     -----------
   --| Digitos |-------------------
   | -----------                  |
   | // propiedades               |
   | Panel                        |
   | Button(12)                   |
   |                       métodos|
   |                        --------------
   |                        | getPanel() | -->
   |                        --------------
   |                              |
   |                        --------------
   |                        | getButton() | -->
   |                        --------------
   |                              |
   |                 Constructores|
   |                        ------------------
   |                        | Digitos(Color) | <--
   |                        ------------------
   |                              |
   |                        -------------
   |                        | Digitos() | <--
   |                        -------------
   |                              |
   --------------------------------

     --------------
   --| Operadores |----------------
   | --------------               |
   | // propiedades               |
   | Panel                        |
   | Button( 4)                   |
   |                       métodos|
   |                        --------------
   |                        | getPanel() | -->
   |                        --------------
   |                              |
   |                        --------------
   |                        | getButton() | -->
   |                        --------------
   |                              |
   |                 Constructores|
   |                        ---------------------
   |                        | Operadores(Color) | <--
   |                        ---------------------
   |                              |
   |                        ----------------
   |                        | Operadores() | <--
   |                        ----------------
   |                              |
   --------------------------------

     --------------
   --| Resultados |----------------
   | --------------               |
   | // propiedades               |
   | Panel                        |
   | TextField                    |
   |                       métodos|
   |                        --------------
   |                        | getPanel() | -->
   |                        --------------
   |                              |
   |                        ------------------
   |                        | getTextField() | -->
   |                        ------------------
   |                              |
   |                 Constructores|
   |                        ---------------------
   |                        | Resultados(Color) | <--
   |                        ---------------------
   |                              |
   |                        ----------------
   |                        | Resultados() | <--
   |                        ----------------
   |                              |
   --------------------------------
   Implementación del interfaz gráfico de usuario

   _JavaDevelopment/testjdk_1.8.0_292/src/Digitos.java
   _JavaDevelopment/testjdk_1.8.0_292/src/PruebaDigitos.java

   _JavaDevelopment/testjdk_1.8.0_292/src/Operadores.java
   _JavaDevelopment/testjdk_1.8.0_292/src/PruebaOperadores.java

   _JavaDevelopment/testjdk_1.8.0_292/src/PruebaResultados.java
   _JavaDevelopment/testjdk_1.8.0_292/src/Resultados.java

    Clase que implementa la interfaz de la calculadora
    _JavaDevelopment/testjdk_1.8.0_292/src/GUICalculadora1.java
    Clase que ejecuta la interfaz GUI de la calculadora1
    _JavaDevelopment/testjdk_1.8.0_292/src/Calculadora1.java

    Sé puede crear otra apariencia de Calculadora:

    Clase que implementa la interfaz de la calculadora
    _JavaDevelopment/testjdk_1.8.0_292/src/GUICalculadora2.java
    Clase que ejecuta la interfaz GUI de la calculadora2
    _JavaDevelopment/testjdk_1.8.0_292/src/Calculadora2.java

    Diseño del Tratamiento de Eventos

    Eventos de ventana --> windowClosing
    Eventos de enfoque --> focusGained y focusLost cuando nos situemos en los botones con el teclado

    -----------------------
    |   GUICalculadora1   |
    ----------------------...............
                     |  ControlFoco     |
                     .......................
                        |  ControlVentana  |
                        ........................
                            |  ControlRaton    |
                            ....................
                                    ^
                                    |
                              OpcionErronea

     ------------------
   --| ControlVentana |------------
   | ------------------           |
   |                       métodos|
   |                        -----------------------------
   |                        | windowClosing(windowEvent)| -->
   |                        -----------------------------
   |                              |
   --------------------------------

     ------------------
   --| ControlFoco    |------------
   | ------------------           |
   | // propiedades               |
   | Color   ^                    |
   |   |     |                    |
   |   |     |              ---------------------
   |   |     <--------------| ControlFoco(Color)| <--
   |   |                    ---------------------
   |   |                   métodos|
   |   |                    --------------------------
   |   |                    | focusGained(focusEvent)| -->
   |   |                    --------------------------
   |   |                          |
   |   |                    ------------------------
   |   -------------------->| focusLost(focusEvent)| -->
   |                        ------------------------
   |                              |
   --------------------------------

    Eventos de ratón 
    Constructor que permite indicar el color del fondo de los botones y el campo de texto del los resultados.

     ------------------
   --| ControlRaton   |------------
   | ------------------           |
   | // propiedades               |
   | TextField                    |
   | Color   ^                    |
   |   |     |                    |
   |   |     |              ---------------------------------
   |   |     <--------------| ControlRaton(TextField, Color)| <--
   |   |                    ---------------------------------
   |   |                   métodos|
   |   |                    ---------------------------
   |   |                    | mouseEntered(mouseEvent)| -->
   |   |                    ---------------------------
   |   |                          |
   |   |                    -------------------------
   |   -------------------->|mouseExited(mouseEvent)| -->
   |                        -------------------------
   |                              |
   |                        ---------------------------
   |                        | mouseClicked(mouseEvent)| -->
   |                        ---------------------------
   |                              |        ^
   --------------------------------        |
                                      OpcionErronea

_JavaDevelopment/testjdk_1.8.0_292/src/ControlVentana.java
_JavaDevelopment/testjdk_1.8.0_292/src/ControlFoco.java
_JavaDevelopment/testjdk_1.8.0_292/src/ControlRaton.java

DISEÑO DEL CONTROL  - MVC - MVControlador - lógica I/O
Pulsaciones del usuario => Input
Resultados => Output

ControlRaton, recoge las pulsaciones que realiza el usuario, (los eventos). 
Procesamiento, realizará el tratamiento de los eventos

ControlRaton le pasará en forma de carácteres("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "=", ".", "+", "-", "*", "/"), para ProcesaEvento.

En caso de que el usuario pulse una opción inadecuada, "ProcesaEvento", generara una Exception.

                --------------------
        --------|   ControlRaton   |
        |       --------------------
        |                ^
        |                |
-----------------        |
| ProcesaEvento |--------|
-----------------        |
                         | 
                --------------------
                |   OpcionErronea  |
                --------------------

El esquema de clases de la app:


         -------------------------
         |    GUICalculadora1    |
         ----------------------------------------------...............
             |       |        |            |        |  ControlFoco     |
             |       |        |            |        .......................
             |       |        |            |           |  ControlVentana  |
             |       |        |            |           .........................
             |       |        |            |  --------------|  ControlRaton    |
             |       |        |            |  |             ....................
             |       |        |            |  |                     ^
             |       |        |            |  |                     |
             |       |        |     -----------------       -----------------
             |       |        |     | ProcesaEvento |       | OpcionErronea |                               
             |       |        |     -----------------       -----------------                          
             | -------------- |                                                                        
             | | Operadores | |                                                                                     
             | -------------- |                                                                        
         -----------          |                                                                        
         | Digitos |          |                                                                                     
         -----------          |                                                                        
                         --------------                                                                        
                         | Resultados |                                                                             
                         --------------                                                                        


--------------      --------------      --------------      --------------      -------------
| Introducir |--->> | Introducir |--->> | Introducir |--->> | Introducir |--->> |  Obtener  |
| Operando 1 |      |  OPERADOR  |      | Operando 2 |      |    SIGNO   |      | Resultado |
--------------      --------------      --------------      --------------      -------------
                           ^                                                           |
                           |___________________________________________________________|

                     -----
                -----| - |----
                |    -----   |
Operando -------|            |
                |    ----------         -----      ----------
                -----| Digito |---------| . |------| Digito |
                     ----------         -----      ----------
                      |____| |                      |____| |
                             |                             |                                
                             ------------------------------------------

ProcesaEvento, implementará el control de la calculadora.
Cajas --> representan los diferentes estados en los que nos podemos encontrar y
Flechas --> son las transiciones permitidas desde cada uno de esos estados

                          -----
                     ---->| - |----
-----------------    |    -----   |
| ProcesaEvento |----|            |
-----------------    |    ----------     -----     ----------
                     ---->| Digito |---->| . |---->| Digito |
                          ----------     -----     ----------
                           ^____| |                 ^____| |
                                  |                        |                                
                                  --------------------------
                                  |
                                  v               -----
                            --------------   ---->| - |----
                            | Introducir |   |    -----   |
                            |  OPERADOR  |---|            |
                            --------------   |    ----------     -----     ----------
                                   ^         ---->| Digito |---->| . |---->| Digito |
                                   |              ----------     -----     ----------
                                   |               ^____| |                 ^____| |
                                   |                      |                        |      -----                     
                                   |                      ------------------------------->| = |
                                   |                                                      -----
                                   |                                                        |
                                   ----------------------------------------------------------

Podemos ver como el usuario va evolucionando según la pulsación de los botones, y podemos conocer las pulsaciones permitidas:
Diagrama de estados:

                          -----      1
                     ---->| - |----
-----------------    |    -----   |
| ProcesaEvento |----|            |  2          3              4
-----------------    |    ----------     -----     ----------
                     ---->| Digito |---->| . |---->| Digito |
                          ----------     -----     ----------
                           ^____| |                 ^____| |
                                  |                        |                                
                                  --------------------------
                                  |
                                  v        5      -----      6
                            --------------   ---->| - |----
                            | Introducir |   |    -----   |
                            |  OPERADOR  |---|            |  7          8              9
                            --------------   |    ----------     -----     ----------
                                   ^         ---->| Digito |---->| . |---->| Digito |
                                   |              ----------     -----     ----------
                                   |               ^____| |                 ^____| |
                                   |                      |                        |      -----   10
                                   |                      ------------------------------->| = |
                                   |                                                      -----
                                   |                                                        |
                                   ----------------------------------------------------------

    Estado 5: hemos recibido ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9" y un operador "+", "-", "*", "/")
    Estado 7: sólo se permite pulsar (".", "=", ó "0", "1", "2", "3", "4", "5", "6", "7", "8", "9")


    ProcesaEvento
    Se definen las propiedades static para evitar pasar la referencia de la instancia de la clase ProcesaEvento a la clase ControlRaton.

    Sin embargo, si en una misma aplicación se quiere crear más de una calculadora, ProcesaEvento no funcionaría ya que todas las calculadoras de la aplicación compartirían las mismas propiedades de estado.

    Si cada calculadora se encontrara en una app separada ProcesaEvento si funciona, ya que cada calculadora se ejecuta sobre una JVM diferente.
    
    Para evitar las propiedades static: 
    - pasar la referencia del objeto ProcesaEvento a la clase ControlRaton.
    - utilizar la referencia pasada en lugar del nombre de la clase cuando la invoca en el try (ProcesaEvento.charPulsado())

_JavaDevelopment/testjdk_1.8.0_292/src/ProcesaEvento.java
_JavaDevelopment/testjdk_1.8.0_292/src/OpcionErronea.java

    Scanner - Escritura desde el teclado - System.in (InputStream)

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassScanner.java

_JavaDevelopment/testjdk_1.8.0_292/src/Scanner_Teclado.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaScanner_Teclado.java

    control flow sequentially

_JavaDevelopment/testjdk_1.8.0_292/src/multipleChoice.java
_JavaDevelopment/testjdk_1.8.0_292/src/calculateAreaTriangle.java

    manipulates control flow
    function or methods or behavior - a series of finite steps that accomplish some task - 
    organize code in a more meaningful way
    define a given task once and use it all throughout our code
    make it easier to change what our code is doing
    returns some value or nothing

_JavaDevelopment/testjdk_1.8.0_292/src/functionsAndMethods.java
_JavaDevelopment/testjdk_1.8.0_292/src/calculateTotalCostOfMeal.java
_JavaDevelopment/testjdk_1.8.0_292/src/splittingtheBill.java

    user-defined functions
    Java has defined some functions for us ie: .equals for Strings 
    just call a built-in function because it's already defined ie: System.out.println()
    dot operator to get access to many of these built-in functions
    Sometimes we'll define our own functions and
    sometimes we'll use built-in functions

    Should I create a custom funcion for exponentiation?
    Is there a built-in function for exponentiation?
    Exponetiation: 2 to the power of 5 is the same as 2*2*2*2*2

https://www.geeksforgeeks.org/math-pow-method-in-java-with-example/

    We did not need to create an instance of Math to use the pow methods
    pow() is a static method (class methods), we call them using the class name
    double result = Math.pow(2,5);

    static methods and non-static methods
_JavaDevelopment/testjdk_1.8.0_292/src/Triangle.java 
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaTriangle.java 

_JavaDevelopment/testjdk_1.8.0_292/src/PruebaClassMath.java 
_JavaDevelopment/testjdk_1.8.0_292/src/calculateEmployeesSalary.java 


    public void incrementExpectedGraduationYear(){
        this.expectedYearToGraduate = this.expectedYearToGraduate + 1;
    }
    
_JavaDevelopment/testjdk_1.8.0_292/src/StudentProfile.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaStudentProfile.java

    public int incrementExpectedGraduationYear(){
        return this.expectedYearToGraduate +1 ;
    }

_JavaDevelopment/testjdk_1.8.0_292/src/StudentProfile2.java
_JavaDevelopment/testjdk_1.8.0_292/src/PruebaStudentProfile2.java

    package generics
    java.util

    List
    ArrayList

    without Generics, you would to cast every single object to a String.
    with Generics, the compiler checks that only strings are added to the list which makes the code safer
    you only need specified once.

_JavaDevelopment/testjdk_1.8.0_292/src/generics/genericsExamples.java

    Devuelve una List de objetos del tipo de Array pasado como parámetro
    this approach (enfoque), significa que pierdes la seguridad de tipos

_JavaDevelopment/testjdk_1.8.0_292/src/generics/genericsmethods.java

    solucionar la seguridad de tipos implica que el method debe ser generic method <T> (generic type)
    no hay errores de compilación ni de ejecución

_JavaDevelopment/testjdk_1.8.0_292/src/generics/generics2methods.java

    para no tener que sobrescribir metodos que tengan un número de argumentos variable:

_JavaDevelopment/testjdk_1.8.0_292/src/varargs/Varargs.java

    metodos que tengan un número de argumentos variable - variable-length-arguments - Varargs,  
    replace [] with ...
    al imprimir puedo pasar el array sin necesidad de crear el array, porque varargs lo hace automaticamente
_JavaDevelopment/testjdk_1.8.0_292/src/varargs/Varargs2.java

Liskov Substitution Principle - OOP

si tienes una variable de un tipo determinado puedes asignarla a un valor que sea un subtipo de ese tipo
if you have a variable of a given type you can assign it to a value that is a subtype of that type
// @ at-sign

    sobrescribe el método toString

_JavaDevelopment/testjdk_1.8.0_292/src/substitutionPrinciple/Building.java
_JavaDevelopment/testjdk_1.8.0_292/src/substitutionPrinciple/Office.java
_JavaDevelopment/testjdk_1.8.0_292/src/substitutionPrinciple/PruebaBuildingOffice.java

wildcards

	_JavaDevelopment/testjdk_1.8.0_292/src/wildcards/Building.java
	_JavaDevelopment/testjdk_1.8.0_292/src/wildcards/House.java
	_JavaDevelopment/testjdk_1.8.0_292/src/wildcards/Office.java

wildcard is essentially an unknown type, give you more flexibility when writing methods
para estar seguro de when you use extends or super with wildcars, think about invariables and outvariables 
método recibe una lista como argumento y esta lista PROVIDES DATA se usa INSIDE the method = INVARIABLE = EXTENDS
método recibe una lista como argumento y se ADDICIONA - GIVE DATA to the list - OUTVARIABLE - SUPER 
NO ES BUENA IDEA USAR WOLDCARS COMO RETURN DE UN METODO - AFECTA HIERARCHIES 

	_JavaDevelopment/testjdk_1.8.0_292/src/wildcards/PruebaBuildingOfficeHouse.java

The Collections Framework in java

- https://docs.oracle.com/javase/tutorial/collections/
- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html

- Is the order important?, 
sometimes it's fine to have all the entries in any random order, but
sometimes it's important to be able to access them in a specific order
- Are duplicates allowed?, 
some situations it's fine to have duplicate entries and others when every entry should be different
- how fast it will be to perform operations
different task operations take different amounts of time to perform certain operations.
some are quick at retrieving entries
some are quicker at adding and removing them
- Memory used is also a Factor
Some types of collections take up more memory than others.

/*
guide-to-selecting-appropiate-map-collection-in-java
A decision tree/guide to Selecting Appropriate Map/Collection in Java
*/

sealed trait Data
case object ValuesWithDuplicates    extends Data
case object ValuesWithoutDuplicates extends Data
case object KeyValuePair            extends Data

sealed trait Order
case object InsertionOrdering extends Order
case object SortedOrdering    extends Order
case object AnyOrdering       extends Order

sealed trait Task
case object AnyTask         extends Task
case object SearchAndRemove extends Task

sealed trait Decision
case object TreeMap       extends Decision
case object LinkedHashMap extends Decision
case object HashMap       extends Decision
case object ArrayList     extends Decision
case object LinkedHashSet extends Decision
case object TreeSet       extends Decision
case object HashSet       extends Decision

case class Problem(data: Data, order: Order, task: Task = AnyTask)

object DataStructureDecisionForJava {

  def decision(problem: Problem): Decision = {
    problem match {
      case Problem(KeyValuePair, order, _) =>
        order match {
          case InsertionOrdering => LinkedHashMap
          case SortedOrdering    => TreeMap
          case AnyOrdering       => HashMap
        }
      case Problem(ValuesWithoutDuplicates, order, task) =>
        (order, task) match {
          case (_, AnyTask) => ArrayList
          case (order, SearchAndRemove) =>
            order match {
              case InsertionOrdering => LinkedHashSet
              case SortedOrdering    => TreeSet
              case AnyOrdering       => HashSet
            }
        }
      case Problem(ValuesWithDuplicates, _, _) => ArrayList
    }
  }
}

/* Unit test can be found here:
assert(decision(Problem(KeyValuePair, AnyOrdering)) == HashMap)
assert(decision(Problem(KeyValuePair, SortedOrdering)) == TreeMap)
assert(decision(Problem(KeyValuePair, InsertionOrdering)) == LinkedHashMap)

assert(decision(Problem(ValuesWithDuplicates, AnyOrdering)) == ArrayList)

assert(decision(Problem(ValuesWithoutDuplicates, AnyOrdering, AnyTask)) == ArrayList)
assert(decision(Problem(ValuesWithoutDuplicates, AnyOrdering, SearchAndRemove)) == HashSet)
assert(decision(Problem(ValuesWithoutDuplicates, InsertionOrdering, SearchAndRemove)) == LinkedHashSet)
assert(decision(Problem(ValuesWithoutDuplicates, SortedOrdering, SearchAndRemove)) == TreeSet)
*/

There is a set of interfaces that define different types of collection

All types of collection implement Iterable 
            ---------------
            |   Iterable  |     - Iterable and it declares the forEach method.
            ---------------
                    |
                    V
            -----------------
    --------|   Collection  |-------  Declares all of the methods that every collection must have: add, remove, is empty, toArray...etc
    |       -----------------      |
    |               |              |    There are no classes that are a concrete implementation of collection directly
    V               V              V
----------  -------------   -------------
|   set  |  |   List    |   |   Queue   |   There is the most commonly used layer of interfaces.
----------  -------------   -------------
Estas interfaces definen un conjunto más específico de comportamientos sobre cómo se comporta la colección.

----------  
|   set  | - No duplicates, Unordered (juego de cartas), 
---------- 
------------- 
|   List    | - Duplicates, Order is also significant(when iterate over a list the items are not returned in a random order)
-------------
-------------
|   Queue   | - Lets you add elements to the heads of the collection. They typically use first-in first-out operations. FIFO. 
-------------   (real life queues in a store)
                    
----------
|   Map  | - Not extend of Collection. They contain (Key,Value) pairs, - HashMap
----------

A Linked List is a doubly linked collection of elements.
Each entry in the list also holds a reference to the address of the next and the previous item in the list.
The main advantage of using a linked list is that they are very quick for inserting and removing elements in the middle of a list.

For most cases, if you have to choose between array list and linked list, the better choise is array list.
Un ArrayList takes up LESS memory than a LinkedList.
Use an ArrayList, but if you know that you will need to add or remove lost of elements in the middle, then a linked list is the better option.

        // There are several classes in the JAVA API that implements the queue interface.
        // One of these classes is linked list, 

_JavaDevelopment/testjdk_1.8.0_292/src/linkedlist/LinkedListExample.java

   Queues are useful way of applying constraints in situatios like this where you want the first item in the queue to be the one that gets removed first.
   poll (method queue interface), returns and remove the first customer in the queue FIFO structure.


_JavaDevelopment/testjdk_1.8.0_292/src/linkedlist/Store.java
_JavaDevelopment/testjdk_1.8.0_292/src/linkedlist/Customer.java


HashMap are unordered, entries are stored by their contents, not by their position
NOT allow duplucate keys
Allow you to have NULL as the value for a key
check the HashMap if contains an entry with a certain key or value
Allow to store pairs of values together (K,V), like phone book.
name of the contact was the key and phone of the contact was the value.
Flexible of accessing elements by when thet were added or modified

_JavaDevelopment/testjdk_1.8.0_292/src/hashmap/HashMapExample.java

When use HashMap is NO guarantee that you can get the entries back in the same order that you put them in 
However, with LinkedHashMap the order is retained.
LinkedHashMap, entries are stored in the same order that you put them it - default: false or no specifies 
You can retrieve entries  in the same order that you put them it (forEach) or

_JavaDevelopment/testjdk_1.8.0_292/src/hashmap/LinkedHashMapExample.java

in the order that they have been accessed in: true - change the contructor al crear el objeto

       {Kevin=123456789, Joe=987654321, Daniel=789456123}
       the longest time ago.............the most recent used

    // Lista of contacts in phoneBook: 
        // Kevin: 123456789     --> at the top -- the longest time ago
        // Daniel: 789456123
        // null: 456123789
        // Joe: 987654321       --> at the botton most recent

_JavaDevelopment/testjdk_1.8.0_292/src/hashmap/LinkedHashMapExample2.java

Lambdas, represent the implementation of a functional interface.

Functional interface is an Interface that has only one abstract method.  
Functional interface allows us to pass code around as data.
annotation functional interface: @FunctionalInterface

_JavaDevelopment/testjdk_1.8.0_292/src/lambdas/GreatingMessage.java

Implement functional interface in another class:

        // Because GreatingMessage has an abstract method with no implementation
        // add every time I create a new instance of GreatingMessage
        // or anonymous inner class 
        // NetBeans automatic implementation
        @Override
        public void greet(String name){
            throw new UnsupportedOperationException("Not supported yet."); 
        }

El resultado de la ejecución es: Hello: Sonia
_JavaDevelopment/testjdk_1.8.0_292/src/lambdas/ImplementGreatingMessage.java

At the moment the codes to implement my functional interface is quite long and messy 
considering all it does is provide one new line of functionality

Lambda provide and simple way to implement functional interfaces in Java:
El resultado de la ejecución es el mismo: Hello: Sonia
_JavaDevelopment/testjdk_1.8.0_292/src/lambdas/LambdaImplementGreatingMessage.java

Es una forma simple de implementar interfaces, lucen un poco diferentes a las anonymous inner classes pero la logica es la misma
más facil de entender cuando se comprende la syntax.

_JavaDevelopment/testjdk_1.8.0_292/src/lambdas/LambdaImplementMessagePrinter.java
_JavaDevelopment/testjdk_1.8.0_292/src/lambdas/MessagePrinter.java


method references are a shorthand way of writing a certain type of lambda expression.
las referencias a métodos son una forma abreviada de escribir un determinado tipo de expresión lambda que pasa en una variable y luego llama a un método sobre esa variable
se puede sustituir por una referencia a un método

Esto es más corto y sencillo que el lambda, begin with the name of the class followed by the name of the method

Shapes shapes = Square::calculateArea;

_JavaDevelopment/testjdk_1.8.0_292/src/methodreferences/MethodReference.java
_JavaDevelopment/testjdk_1.8.0_292/src/methodreferences/Shapes.java
_JavaDevelopment/testjdk_1.8.0_292/src/methodreferences/Square.java














Exercises - https://docs.oracle.com/javase/tutorial

https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html

_JavaDevelopment/testjdk_1.8.0_292/src/JavaTutorials/Arrays.java


bugs: 
    Syntax errors can cause your program to fail before it is run
    - RIGHT format
    - misspelled variable or missing semicolon
    Logical errors
    - the program is able to run but it doesn't act as the user expects
    To solve these, we look for components of the program that aren't as expected, find their respective code and fix it.

    A breakpoint is an intentional stopping point put into a program for debugging purposes
    Temporarily halt a program in order to inspect its internal state
    Internal state: variables values, the result of certain lines of code, whether or not a certain line of code is executed.

    A varible scope (alcance) refers to where we can access and use the variable in our program

    Las variables declaradas directamente dentro de un método están disponibles en cualquier parte del método después de la línea de código en la que fueron declaradas

    bloque de código se refiere a todo el código entre llaves {}.  
    Las variables declaradas dentro de los bloques de código sólo son accesibles por el código entre las llaves.

    Un bloque de código puede existir por sí mismo o puede pertenecer a una sentencia if, while o for. En el caso de las sentencias for, las variables declaradas en la propia sentencia también están disponibles dentro del ámbito del bloque.
    

     Java module descriptor (module-info.java)?
        
        requires, exports

        testjdk_1.8.0_292/src/modules/HelloModularWorld.java
        testjdk_1.8.0_292/src/module-info.java
        
    https://nipafx.dev/java-module-system-tutorial/#modules


GENERALES:
----------
(parentheses or round brackets)  
[square brackets] 
<angled brackets> 
{Braces or curly brackets}
Data is information that is stored and processed by an computer.
CLASSPATH, indica donde se encuentran los objeto (*.class) y la instalación la actualiza.
La variable de entorno CLASSPATH se especifica de manera diferente según cual sea el SO que utilizamos.
Los ubicación de los ejecutables del SDK por defecto, depende de la version del SDK y pueden instalarse en cualquier lugar.
La ayuda del SDK, se accede a través del index.html, contiene un enlace importante referente al API, proporciona información sobre los métodos y clases disponibles.
Los programas en Java No deben incluir números de línea
La estructura mínima de un programa Java como mínimo: 
- Debe definirse una clase,
- Debe definirse un método main,
- Debe utilizarse un parámetro String[], aunque no se use.
En un programa Java se debe tener en cuenta:
- Las estructuras (clases, métodos) se delimitan con {llaves de comienzo y final}
- El carácter ';', sirve para separar instrucciones
- Una clase declarada como pública es accesible a cualquier otra clase.
El fuente, (código) de un programa se debe grabar con formato de texto ASCII, y extensión java
Los errores de compilación pueden ser por:
- errores en el código
- el fichero esta guardado en un formato inadecuado y/o con extensión inadecuada (debe ser java)
- para compilar con con javac: javac nombredelfichero.java
Los nombres de las variables NO deben contener espacios en blanco, y pueden empezar por una [A-Z, a-z], "$", ó "_"
Los tipos de datos permiten que el traductor realice comprobaciones estáticas respecto a la corrección del programa y permiten clasificar a las variables según su naturaleza.
Ex:    
   short Short = 12826;
   long Long = 26;
   float $Float = 12.6f;
   boolean Boolean = true;
   char Char = 'S';
   short SegundoShort = (short) (200+112); 
For es adecuando cuando conocemos a priori el número de iteraciones
For obliga a evaluar la condición de finalización al comienzo del bucle
While es adecuado cuando no conocemos a priori el número de iteraciones
While Tiene dos variantes: una en la que se evalúa la condición de finalización, al comienzo del bucle y otra al final del mismo
if Permite cualquier número de operaciones y permite expresiones con operadores de comparación y operadores lógicos
Es más eficiente una solución con if anidados 
Los if anidados no tienen límite fijado por el lenguaje
En un Switch se puede definir un número ilimitado de ramas basadas en una misma condición
Los 'case', definen los valores que se comparan con el resultado de la condición del switch
La instrucción switch se termina cuando el flujo de control llega a una clausula break ó a una clausula switch
switch puede contener una cláusula 'default'
switch puede devolver valores de tipo: short, int, char, byte
métodos: 
- permiten encapsular instrucciones, 
- pueden contener cualquier número y tipo de instrucciones, 
- pueden ser invocados desde diferentes lugares de una app.
- cuando se devuelve un valor se debe indicar el tipo antes del nombre
- cuando NO se devuelve un valor se debe indicar void antes del nombre
Ex:
si public float getPrecio(){};
puedo: float Precio = getPrecio(); if (getPrecio>200f)..
Los parámetros pertenecen al método y los argumentos al programa llamante y cada parámetro debe corresponder en tipo con su argumento
'return' debe ser la última instrucción de un método y puede presentarse sin argumento
cuando se devuelve un valor debe contener return;
??? cuando NO se devuelve un valor debe ó puede contener return;
Los argumentos basados en tipos primitivos (byte, short, int, long, char, float, double y boolean), de datos son pasados por valor
Los argumentos NO basados en tipos primitivos (byte, short, int, long, char, float, double y boolean), de datos son pasados por referencia
Los argumentos pasados por valor nunca quedan modificados después de la ejecución de los métodos
Los argumentos pasados por referencia pueden ser modificados en los métodos llamados.
El método sqrt de la clase Math devuelve un resultado de tipo double
Los String NO son tipos nativos de datos, son Reference Types y no funcionan igual que los tipo char, y se concatenan con "+".
Un String con valor null es diferente a un String con valor ""
equals compara dos Strings carácter a carácter
Si dos variables String apuntan a la misma estructura de datos, al compararlos con "==" or con "equals" el resultado es true
length devuelve la longitud el String
int[] x; int x[] producen el mismo resultado
float[]x = {1.1f, 2.2f, 3.3f}; float[] x = new float[3] definen una matriz de 3 elementos
x[2]=1.1f; float[] x = {1.1f, 2.2f}; float[] x={1.1f}; estan bien definidas
Las matrices pueden ser recorridas mediante bucles
Los argumentos de tipo Matriz se escriben SIN corchetes y los parámetros CON corchetes
Las clases pueden contener propiedades y métodos ó pueden contener sólo propiedades ó pueden contener sólo métodos
Las propiedades de una clase definen su estado
Las propiedades privadas de una clase son accesibles directemente desde el interior de la clase 
Los métodos publicos de una clase son accesibles desde el exterior de esa clase 
Las instancias de una misma clase NO comparten las propiedades de esa clase
No existe un límite definido al número de instancias de una clase que podemos crear
Se instancia con new y se usa notación punto para acceder a una propiedad o a un método de una instancia de clase.
Los métodos sobrecargados:
- Deben tener el mismo nombre y NO deben presentar la misma firma
La firma de un método se define por el nombre del método, el número y tipo de parametros atendiendo al orden de colocación.
Los constructores:
- nos permiten iniciliazar el estado de una clase en el momento de su instanciación, 
- admiten sobrecarga y deben denominarse igual que la clase que les contiene, 
- tienen implicito el atributo de acceso public y el atributo de retorno void.
clases como parámetros (class):
- podemos aplicar los métodos de una clase sobre las propiedades de diferentes instancias de otra clase.
- podemos pasar distintas instancias de una clase a los métodos (incluidos constructores) de otra clase.
Las propiedades de instancia de una clase:
- se crean cada vez que se define una instancia de la clase.
Las propiedades estáticas de clase de una clase:
- existen a partir de la definición de la clase
- son compartidas por todas las instancias de esa clase
- Se pueden referenciar a través del nombre de la clase
Los métodos de instancia se pueden referenciar a través del nombre de su clase.
Los métodos de clase se pueden referenciar a través del nombre de su clase y a través del nombre de una instancia de su clase.
Los métodos estáticos de clase solo pueden referenciar objetos estáticos.
Las propiedades estáticas de una clase nos permiten que distintas instancias de esa clase compartan sus valores.
Una clase puede contener simultaneamente objetos de clase y de instancia.
La sentencia 'package' de existir debe ser la primera de un fichero .java
Los miembros públicos de una clase son accesibles desde las clases situadas en otros paquetes.
SÓLO se pueden usar desde fuera de un paquete las clases definidas como públicas dentro de ese paquete.
Las clases definidas como public pueden ser accesibles desde fuera del paquete.
Las que no, sólo son accesibles desde dentro del paquete(sirven para dar soporte a las clases públicas)
Herencia sirve para crear subclases/clases derivadas que especializan los miembros (propiedades y métodos) de la super clase.
El método super(parámetros) invoca al constructor de la superclase que coincida en firma con la llamada.
Si se usa super, debe ser (obligatoriamente) la primera sentencia del constructor.
una clase sólo puede heredar de otra clase
Polimorfismo 
- se resuelve en tiempo de ejecución.
- permite invocar a métodos de diferentes subclases haciendo uso de una misma referencia
- el método polimórfico debe existir en las subclases y en la superclase
- la referencia a partir de la que se invoca al método polimórfico debe ser del tipo de la superclase
Las clases abstractas 
- contienen al menos un método abstracto
- pueden tener todos sus métodos abstractos
- facilitan el diseño y desarrollo orientado a objetos
- permiten implementar con elegancia el mecanismo de polimorfismo
- Una clase abstracta pertenece a una jerarquía de clases mientras que una interfaz no pertenece a una jerarquía de clases. 
Los métodos abstractos Se declaran(acabando con el símbolo ";") y no se definen
Las interfaces
- Sólo pueden contener constantes y métodos abstractos
- Pueden contener sólo constantes
- NO implementan interfaces
- NO extienden interfaces ni clases
- Puede extender multiples superinterfaces, es decir, lista separada por comas de todas las interfaces que la nueva interfaz va a extender
- especifica qué se debe hacer, pero no cómo hacerlo
Una clase puede implementar varias interfaces, pero sólo puede tener una clase ascendiente directa. 
Clases sin relación de herencia pueden implementar la misma interfaz.
No se puede crear una instancia de un interfaz
No se puede crear una instancia de una clase abstracta
Las excepciones permiten separar la lógica del programa de las instruciones de control de errores, se tratan haciendo uso de la clase Throwable y sus clases derivadas 
Existen excepciones que obligatoriamente deben ser tratadas y otras que no
Es más habitual tratar excepciones de tipo Exception que de tipo Error
Cada bloque try puede tener asociado varios bloques catch
El bloque finally de existir, siempre se ejecuta
Las excepciones pueden propagarse entre métodos
Las instrucciones throw nos permiten propagar excepiciones
Cuando se produce una excepción, puede que provoque la ejecución de dos bloques 'catch' del mismo tipo, estando los bloques 'catch' en diferentes métodos.
El orden de colocación de los bloques catch es importante
Las excepciones definidas por el programador cubren situaciones erróneas que tienen que ver con la naturaleza de las aplicaciones, pueden contener miembros (propiedades y métodos).
throw se utiliza para levantar excepciones por programa.
throws se emplea en la declaración de un método.

Encapsulation - ENCAPSULAR

Para asegurarse de que los datos "sensibles" estén ocultos a los usuarios. 
- debe declarar las variables/atributos de la clase como privados "private"
- proporcionar métodos públicos get y set para acceder y actualizar el valor de una variable/atributo private

Las variables privadas sólo pueden ser accedidas dentro de la misma clase.
(una clase externa no tiene acceso a ella). 
Sin embargo, es posible acceder a ellas si proporcionamos métodos públicos get y set

El método get devuelve el valor de la variable, y 
el método set establece el valor.

La sintaxis de ambos es: get o set, seguido del nombre de la variable, con la primera letra en mayúscula


Mejor control de los atributos y métodos de la clase
Los atributos de la clase pueden ser 
de sólo lectura (si sólo se utiliza el método get), o 
de sólo escritura (si sólo se utiliza el método set)
Flexibilidad: el programador puede cambiar una parte del código sin afectar a otras partes Mayor seguridad de los datos

_JavaDevelopment/javasrc-main/src/testing/Encapsutar_test.java
_JavaDevelopment/javasrc-main/src/testing/Encapsular.java

Java Packages & API

- Built-in Packages (packages from the Java API)
  Es una biblioteca de clases preescritas, de uso gratuito, incluidas en el entorno de desarrollo de Java.

  La biblioteca contiene componentes para la gestión de entradas, la programación de bases de datos y mucho más. 
  La lista completa puede encontrarse en el sitio web de Oracle: 
  https://docs.oracle.com/javase/8/docs/api/    --> hasta la 10
  https://docs.oracle.com/en/java/javase/11/docs/api/

  import package.name.Class;    // Import una clase del package
  import package.name.*;        // Import todo package

- User-defined Packages (create your own packages)

  Para crear un paquete, Java utiliza un directorio del sistema de archivos para almacenarlos. 
  proyecto/src/

  com/others/*.java
  package com.others.*;         // Import todo el package
  package com.others.Class*;    // Import una clase del package

vi Class.java -> crea el fichero de la clase 
javac Class.java --> crea el class en el mismo sitio desde donde lo compile
javac -d . Class.java --> crea el class dentro del package que se haya indicado en el Class.java




Object es la raiz de toda la jerarquia de clases
Con la clase window se obtienen ventanas sin bordes y sin posibilidad de incluir barras de MENUS
Frame es más especializada que la clase Window, tiene un constructor que admite el título de la ventana, permite incluir barra de menús, es necesario invocar el método setVisible, y setSize, podemos instanciar cuantos Frames como deseemos.
Es posible trabajar con varias ventanas simultaneas.
Los componentes son menos especializados que los contenedores
Los botones no son subclases de los contenedores
Los paneles son subclases de los contenedores
Los Layouts permiten colocar los componentes con diferentes disposiciones y se pueden asociar a los paneles
FlowLayout es el layout que se asigna por defecto a los paneles, admite alineamiento horizontal.
BorderLayout contiene 5 regiones cardinales.
GridLayout divide el espacio de manera matricial (en rejilla), admite 2 parámetros filas y columnas
La clase Container es subclase de Component, y superclase directa de Panel, los paneles son Container.
La clase Label permite que se les defina un alineamiento, pueden ser variadas en tiempo de ejecución, derivan directamente de la clase Component
Los campos TextField pueden instanciarse indicando un texto inicial, permiten definir el número de carácteres de edición
Las fuentes Font, permiten definir el tamaño de los textos , el tipo de letra de los componentes.
TextArea deriva de TextComponent, puede configurarse para incluir o no barras de desplazamiento.
Checkbox admite un constructor vacio, tiene asociada una etiqueta identificativa.
CheckboxGroup permiten agrupar un conjunto de Checkbox, la activación de un elemento implica la desactivación del otro, derivan de Object
List, permite selecciones multiples, selecciones de un único elemento, configurarse para visualizar un número determinado de elementos, (el resto si los hay, pueden ser accedidos mediante barras de desplazamiento).
Choice, proporciona el método add para añadir elementos.
Diseño de formularios, la solución implementada con varias clases permite reutilizar y añadir código con mayor facilidad, además esta mejor diseñada desde el punto de vista de POO.
Dialogos, deben estar asociados a un propietario (Frame o Dialog), pueden ser modales o no modales.
FileDialog sólo admite como propietario un Frame, permiten establecer un directorio inicial para buscar el fichero, pueden ser modales y no modales.
MenuBar, solo pueden situarse sobre objetos Frame, Sólo presentan el constructor vacio, permiten añadir menus.
Menu pueden ser añadidos a las barras de menús.
Eventos, provienen en general de las interrupciones de hardware, son visibles de manera automática sin necesidad de invocar a ningún método, se tratan haciendo uso de los adaptadores xxxAdapter
Algunos interfaces xxxListener tienen asociada una clase xxxAdapter, y todos los interfaces xxxListener reciben un evento xxxEvent.
JVM interviene en el mecanismo de tratamiento de eventos, los eventos son objetos que crea la JVM.
Los métodos de tratamiento de eventos se encuentran en los interfaces xxxListener.
Los componentes AWT de una aplicación pueden tener asociado uno o más de un listener o adapter.
La asociación entre un componente y sus adaptadores se define mediante los métodos addxxxListener
Los eventos de ratón y movimiento de ratón utilizan los objetos de evento MouseEvent y MouseWheelEvent
El interfaz MouseMotionListener Contiene los métodos mouseDragged y mouseMoved, utiliza el evento MouseEvent que permite conocer el objeto que ha generado el evento, la posición x, y en la que se ha generado el evento(relativa a la esquina superior izquierda del componente)
Para asociar el componente a una clase de tratamiento de evento de ratón se usa el método addMouseListener.
Para asociar el componente a una clase de tratamiento de evento de movimiento de ratón se usa el método addMouseMotionListener.
Para asociar el componente a una clase de tratamiento de evento de teclado se usa el método addKeyListener.
El interfaz MouseMotionListener, contiene el método mouseDragged.
El interfaz KeyListener contiene 3 métodos, tiene asociado el adaptador KeyAdapter
El interfaz WindowListener contienen el método windowClosed
El objeto KeyEvent contiene el metodo getKeyCode
focusGained es un método del interfaz FocusListener y de la clase FocusAdapter
itemStateChanged es un método del interfaz ItemListener
Los métodos addItemListener y addActionListener existen

--------------------------------------------------------------------------------------------------------------
| Modifier       | Used with                       | Description                                             |
--------------------------------------------------------------------------------------------------------------
|                | Outer classes, interfaces,      | A class or interface may be accessed from outside the   |
|  Public        | constructors, Inner classes,    | package. Constructors, inner classes, methods and field |
|                | methods, and field variables    | variables may be accessed wherever their class is       |
|                |                                 | accessed                                                |
--------------------------------------------------------------------------------------------------------------
|                | Constructors, inner classes,    | Accesed by other classes in the same package or any     |
|  Protected     | methods, and field variables    | subclasses of the class in which they are referred(i.e. |
|                |                                 | same package or different package                       |
--------------------------------------------------------------------------------------------------------------
|                | Constructors, inner classes,    | Accesed only within the class in which they are         |
|  Private       | methods, and field variables    | declared                                                |
|                |                                 |                                                         |
--------------------------------------------------------------------------------------------------------------
| No modifier:   | Outer classes, inner classes,   | Accesed only from within the package in which they are  |
| (Package by    | interfaces, constructors,       | declared                                                |
|  default)      | methods, and field variables    |
--------------------------------------------------------------------------------------------------------------

--O-J-O-- --O-J-O-- --O-J-O-- --O-J-O-- --O-J-O--

// pendientes npi

/*
Se puede reemplazar por la llamada a un método que sea capas de leer de la consola
System.out.println ("Introduce la matricula: ");
Scanner sc = new Scanner(System.in);
String matricula = sc.next();
*/

// pendiente de picar y de probar el código

	InstanceOf.java
    public class InstanceOf{
    public static void main (String[]args){
        if( Impuesto instanceof float) {
            System.out.println("Impuesto is a float");
        }
        else if( Impuesto instanceof Integer) {
            System.out.println("Impuesto is an Integer");anonymous
        }
        
        if( Impuesto instanceof Comparable) {
            //subclasses of Number like Double etc. implement Comparable
            //other subclasses might not -> you could pass Number instances that don't implement that interface
            System.out.println("Impuesto is comparable"); 
        }
    }
}


EditorTexto - , contiene el inicio del Editor de Texto
GUIEditor.java
EventosMenu.java
PruebaGUIEditor.java


Revisar - Calculadora - Packages - ,  contiene las clases Digitos, Operadores, Resultados, GUICalculadora* y Calculadora* 
                                      esta sin importar MyFrame1 ..etc y sin modificar el package
ControlFoco.java
ControlRaton.java
ControlVentana.java
GUICalculadora1.java
GUICalculadora2.java
Calculadora2.java
Calculadora1.java
PruebaResultados.java
Resultados.java
PruebaOperadores.java
Operadores.java
Digitos.java
ProcesaEvento.java
OpcionErronea.java
PruebaDigitos.java

SkillAssessments, contiene ejercicios de cursos de pruebas
                                    
---------------------------
|  _____________________  |
| |                     | |
| |_____________________| |
---------------------------
| ----- ----- ----- ----- |
| | 7 | | 8 | | 9 | | + | |     -> 2*3+1;   2*3+2;    2*3+3;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 4 | | 5 | | 6 | | - | |     -> 1*3+1;   1*3+2;    1*3+3;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 1 | | 2 | | 3 | | * | |     -> 0*3+1;   0*3+2;    0*3+3;
| ----- ----- ----- ----- |
| ----- ----- ----- ----- |
| | 0 | | . | | = | | / | |     ->     0;       .;        =;
| ----- ----- ----- ----- |
---------------------------

GUI mejorada
----------------------------------
|  ____________________________  |
| |                            | |
| |____________________________| |
----------------------------------
| ----- ----- ----- -----  ----- |
| | 7 | | 8 | | 9 | | % |  | / | |
| ----- ----- ----- -----  ----- |
| ----- ----- ----- ----- ------ |
| | 4 | | 5 | | 6 | | * | |sqrt| |
| ----- ----- ----- ----- ------ |
| ----- ----- ----- -----  ----- |
| | 1 | | 2 | | 3 | |   |  | - | |
| ----- ----- ----- | + |  ----- |
| ----- ----- ----- |   |  ----- |
| | C | | 0 | | . | |   |  | = | |
| ----- ----- ----- -----  ----- |
----------------------------------


/*
Comparator c = new Comparator();
Collections.sort(list, c);
http://tutorials.jenkov.com/java-collections/sorting.html

            int NUM_BUNNY=5;
            List list = new List(NUM_BUNNY);

            List Bunny = new List(Bunny);

            for (int i = 0; i < numbers.length; i++)    // 0000000000
                System.out.print(numbers[i]);
        */







https://javacook.darwinsys.com/
https://javacook.darwinsys.com/download.html
https://github.com/IanDarwin/javasrc

ISNB: 978-1492072583 ??
Java Cookbook
Ian F. Darwin
Publisher: O'Reilly Media.

Jikes: http://oss.software.ibm.com/developerworks/projects/jikes <==> https://developer.ibm.com/devpractices/open-source-development/
cd /usr/ports/lang/jikes
sudo make install
https://github.com/kaffe/kaffe

http://node.org


Mac OS: Xcode and interface Builder

java.awt.Toolkit
java.lang.Runtime
System.exit()
Runtime.exit()

javac HelloWorld.java
java HelloWorld

Main-Class: HelloWorld
jar cvmf manifiest.stub hello.jar HelloWorld.class
java -jar hello.jar

- Obtener las variables de entorno:

_JavaDevelopment/javasrc-main/src/com/others/GetEnv.java
		/*
		 * Devuelve todas las variables de entorno en forma de String Map no modificable. 
		 */
		System.out.println("System.getenv(\"PATH\") = " + System.getenv("PATH"));

System.getenv("PATH") = /home/hadoop/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin

JUnit es una metodología centrada en Java para proporcioar casos de prueba que se puede descargar de forma gratuita del sitio: http://www.junit.org.
Basta con escribir una serie de métodos que empiezan por test.
JUnit busca todos estos métodos y los ejecuta de forma automática.
Las extensiones de JUnit gestionan tareas tan diversas como cargar pruebas o probar Enterprise JavaBeans(JEB)

_JavaDevelopment/javasrc-main/src/testing/PersonTest.java

package testing;

import com.others.Person;

import junit.framework.*;

/**
 * Un caso de prueba ara la clase Person
 * @author hadoop
 *
 */

public class PersonTest extends TestCase{
	
	/*
	 * Las clases de prueba de JUnit requieren este constructor
	 */
	public PersonTest(String name) {
		super(name);
	}
	
	public void testNameConcat() {
		Person p = new Person("Sonia", "Celis");
		String f = p.getFullName();
		assertEquals(f, "Sonia Celis");
	}

}

_JavaDevelopment/javasrc-main/src/com/others/Person.java

(base) hadoop@sc-ubuntu-20-04-2-lts:~/_JavaDevelopment/javasrc-main/src$ cat com/others/Person.java
package com.others;

/*
 * Pruebas de unidades
 */
public class Person {
	protected String fullName;
	protected String firstName, lastName;

	/*
	 * Construye un objeto Person mediante el nombre y el apellido de una persona
	 */
	
	public Person(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	
	/*
	 * Obtiene el nombre completo de la persona
	 */
	public String getFullName() {
		if(fullName != null)
			return fullName;
		return firstName + "" + lastName;
	}
	
	/*
	 * Programa de prueba sencilla
	 */
	
	public static void main(String[] args) {
		Person p = new Person("Sonia", "Celis");
		String f = p.getFullName();
		if (!f.equals("Sonia Celis")) 
			throw new IllegalStateException("Name concatenation broken");
	System.out.println("Fullname: " + f + " looks good");
	}
}

- Obtener información de las propiedades del sistema:
_JavaDevelopment/javasrc-main/src/com/others/GetProp.java

java.util.Properties: https://docs.oracle.com/javase/7/docs/api/java/util/Properties.html

package com.others;

public class GetProp {

	public static void main(String[] args) {
		/*
		 * Devuelve las propiedades del systema
		 * 
		 */
		System.out.println("System.getProperties() = " +
		System.getProperties());

		/*
		 * Devuelve el valor de la propiedad "java.runtime.name" 
		 * 
		 */		
		System.out.println("System.getProperty(\"java.runtime.name\") = " + 
		System.getProperty("java.runtime.name"));
		
		String os_name = System.getProperty("os.name");
		System.out.println("System.getProperty(\"os.name\")=  " + os_name);
		
        String os_arch = System.getProperty("os.arch");
		System.out.println("System.getProperty(\"os.arch\")=  " + os_arch);

        String os_version = System.getProperty("os.version");
		System.out.println("System.getProperty(\"os.version\")=  " + os_version);

        String java_class_path = System.getProperty("java.class.path");
		System.out.println("System.getProperty(\"java.class.path\")=  " + java_class_path);
		
        String java_lang_version = System.getProperty("java.lang.version");
		System.out.println("System.getProperty(\"java.lang.version\")=  " + java_lang_version);

        System.out.println("System.getProperty(\"java.specification.version\")= " + System.getProperty("java.specification.version"));

        /*establecer una propiedad - set */

        System.setProperty("pencil color", "Red");

        String pencil_color= System.getProperty("pencil color");
		System.out.println("System.getProperty(\"pencil color\")=  " + pencil_color);
		
		System.getProperties().list(System.out);

	}



System.getProperties() = {java.runtime.name=Java(TM) SE Runtime Environment, sun.boot.library.path=/opt/java-jdk/jdk1.8.0_231/jre/lib/amd64, java.vm.version=25.231-b11, java.vm.vendor=Oracle Corporation, java.vendor.url=http://java.oracle.com/, path.separator=:, java.vm.name=Java HotSpot(TM) 64-Bit Server VM, file.encoding.pkg=sun.io, user.country=GB, sun.java.launcher=SUN_STANDARD, sun.os.patch.level=unknown, java.vm.specification.name=Java Virtual Machine Specification, user.dir=/home/hadoop/eclipse-workspace/javasrc-main, java.runtime.version=1.8.0_231-b11, java.awt.graphicsenv=sun.awt.X11GraphicsEnvironment, java.endorsed.dirs=/opt/java-jdk/jdk1.8.0_231/jre/lib/endorsed, os.arch=amd64, java.io.tmpdir=/tmp, line.separator=
, java.vm.specification.vendor=Oracle Corporation, os.name=Linux, sun.jnu.encoding=UTF-8, java.library.path=/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib, java.specification.name=Java Platform API Specification, java.class.version=52.0, sun.management.compiler=HotSpot 64-Bit Tiered Compilers, os.version=5.4.0-72-generic, user.home=/home/hadoop, user.timezone=, java.awt.printerjob=sun.print.PSPrinterJob, file.encoding=UTF-8, java.specification.version=1.8, java.class.path=/home/hadoop/eclipse-workspace/javasrc-main/bin:/home/hadoop/.p2/pool/plugins/org.junit.jupiter.api_5.8.1.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.junit.jupiter.engine_5.8.1.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.junit.jupiter.migrationsupport_5.8.1.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.junit.jupiter.params_5.8.1.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.junit.platform.commons_1.8.1.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.junit.platform.engine_1.8.1.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.junit.platform.launcher_1.8.1.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.junit.platform.runner_1.8.1.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.junit.platform.suite.api_1.8.1.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.junit.platform.suite.engine_1.8.1.v20211028-1957.jar:/home/hadoop/.p2/pool/plugins/org.junit.platform.suite.commons_1.8.1.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.junit.vintage.engine_5.8.1.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.opentest4j_1.2.0.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.apiguardian_1.1.2.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.junit_4.13.2.v20211018-1956.jar:/home/hadoop/.p2/pool/plugins/org.hamcrest.core_1.3.0.v20180420-1519.jar, user.name=hadoop, java.vm.specification.version=1.8, sun.java.command=com.others.GetProp, java.home=/opt/java-jdk/jdk1.8.0_231/jre, sun.arch.data.model=64, user.language=en, java.specification.vendor=Oracle Corporation, awt.toolkit=sun.awt.X11.XToolkit, java.vm.info=mixed mode, java.version=1.8.0_231, java.ext.dirs=/opt/java-jdk/jdk1.8.0_231/jre/lib/ext:/usr/java/packages/lib/ext, sun.boot.class.path=/opt/java-jdk/jdk1.8.0_231/jre/lib/resources.jar:/opt/java-jdk/jdk1.8.0_231/jre/lib/rt.jar:/opt/java-jdk/jdk1.8.0_231/jre/lib/sunrsasign.jar:/opt/java-jdk/jdk1.8.0_231/jre/lib/jsse.jar:/opt/java-jdk/jdk1.8.0_231/jre/lib/jce.jar:/opt/java-jdk/jdk1.8.0_231/jre/lib/charsets.jar:/opt/java-jdk/jdk1.8.0_231/jre/lib/jfr.jar:/opt/java-jdk/jdk1.8.0_231/jre/classes, java.vendor=Oracle Corporation, file.separator=/, java.vendor.url.bug=http://bugreport.sun.com/bugreport/, sun.io.unicode.encoding=UnicodeLittle, sun.cpu.endian=little, sun.desktop=gnome, sun.cpu.isalist=}

System.getProperty("java.runtime.name") = Java(TM) SE Runtime Environment

System.getProperty("os.name")=  Linux

System.getProperty("java.lang.version")=  null

System.getProperty("java.specification.version")= 1.8

System.getProperty("pencil color")=  Red

-- listing properties --
pencil color=Red
java.runtime.name=Java(TM) SE Runtime Environment
sun.boot.library.path=/opt/java-jdk/jdk1.8.0_231/jre/lib/amd64
java.vm.version=25.231-b11
java.vm.vendor=Oracle Corporation
java.vendor.url=http://java.oracle.com/
path.separator=:
java.vm.name=Java HotSpot(TM) 64-Bit Server VM
file.encoding.pkg=sun.io
user.country=GB
sun.java.launcher=SUN_STANDARD
sun.os.patch.level=unknown
java.vm.specification.name=Java Virtual Machine Specification
user.dir=/home/hadoop/eclipse-workspace/javasr...
java.runtime.version=1.8.0_231-b11
java.awt.graphicsenv=sun.awt.X11GraphicsEnvironment
java.endorsed.dirs=/opt/java-jdk/jdk1.8.0_231/jre/lib/en...
os.arch=amd64
java.io.tmpdir=/tmp
line.separator=

java.vm.specification.vendor=Oracle Corporation
os.name=Linux
sun.jnu.encoding=UTF-8
java.library.path=/usr/java/packages/lib/amd64:/usr/lib...
java.specification.name=Java Platform API Specification
java.class.version=52.0
sun.management.compiler=HotSpot 64-Bit Tiered Compilers
os.version=5.4.0-72-generic
user.home=/home/hadoop
user.timezone=
java.awt.printerjob=sun.print.PSPrinterJob
file.encoding=UTF-8
java.specification.version=1.8
user.name=hadoop
java.class.path=/home/hadoop/eclipse-workspace/javasr...
java.vm.specification.version=1.8
sun.arch.data.model=64
java.home=/opt/java-jdk/jdk1.8.0_231/jre
sun.java.command=com.others.GetProp
java.specification.vendor=Oracle Corporation
user.language=en
awt.toolkit=sun.awt.X11.XToolkit
java.vm.info=mixed mode
java.version=1.8.0_231
java.ext.dirs=/opt/java-jdk/jdk1.8.0_231/jre/lib/ex...
sun.boot.class.path=/opt/java-jdk/jdk1.8.0_231/jre/lib/re...
java.vendor=Oracle Corporation
file.separator=/
java.vendor.url.bug=http://bugreport.sun.com/bugreport/
sun.cpu.endian=little
sun.io.unicode.encoding=UnicodeLittle
sun.desktop=gnome
sun.cpu.isalist=

- Saber la versión del kit de desarrollo java (JDK) que se corresponde con el sistema en tiempo de ejecución Java

    System.getProperty("java.specification.version")

- Comprobar la presencia o ausencia de clases concretas:

    Class.forName("class")
    Ejemplo para comprobar si la clase java.lang.reflect.Constructor existe en el jdk que estoy ejecutando
    esta clase se añadio en la versión 1.1 pero no estaba presente en la 1.0
    El javadoc de las clases standard informa de la versión en la que se añadió.
    
    https://es.wikipedia.org/wiki/Javadoc
    https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#tag
    @since --> si no existe, quiere decir que la clase ha estado presente desde el principio, es decir, desde JDK 1.0
    
    https://docs.oracle.com/javase/8/docs/api/


	Class.forName("java.lang.reflect.Constructor");

    https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html


_JavaDevelopment/javasrc-main/src/com/others/GetClassforName.java

package com.others;

public class GetClassforName {

	public static void main(String[] args) {
		/*
		 * Para saber si una clase esta presente ó no en la biblioteca del sistema en tiempo de ejecución. 
		 * 
		 */
		try {
			
			Class.forName("java.lang.reflect.Constructor");
			
		} catch (ClassNotFoundException e) { 
			
			String failure = "Sorry, pero esta version of MyApp necesita un Java Runtime based on Java JDK 1.1 or later";
			System.err.println(failure);
			throw new IllegalArgumentException(failure);
		
		}

		System.out.println("Happy de informar que this Java Runtime is ok for MyApp");
		return;
	}

}

- Para saber si el sistema en tiempo de ejecución incluye los componentes Swing con los nombre finales, podemos usar: 
  Esta comprobación no la veremos si la escribimos en el constructor de una subclase JPanel

			Class.forName("javax.swing.JButton"); 

Este código debería colocarse al principio del flujo principal de la aplicación, antes de que se construya ningún otro objeto de la interfaz gráfica de usuario.

- Para saber si utilizar "/" ó "\" en caso de que necesitemos generar nombres de archivo y/o necesitemos utilizar cualquier otro carácter.

- Enumerar las propiedades del sistema. - System.getProperty

_JavaDevelopment/javasrc-main/src/com/others/SysPropDemo.java

package com.others;

import java.util.*;

public class SysPropDemo {

	public static void main(String[] args) {
		/*
		 * Demuestra las propiedades del sistema
		 */
		System.out.println("System Properties: ");
		Properties p = System.getProperties();
		p.list(System.out);
	}

}

package com.others;

public class SysDep {
	/*
	 * Algunos sistemas operativos proporcionan un mecanismo denominado
	 * "el dispositivo nulo", que permite descartar los resultados (normalmente utilizado para calcular el tiempo)
	 * Pregunta a las propiedades del sistema por os.name y 
	 * utiliza esta propiedad para configurar un nombre (en este caso junk), que se pueda utilizar para descartar datos.
	 * Si no se conoce ningún dispositovo nulo para la plataforma dada, se devuelve un nombre no deseado,
	 * lo que significa que en tales plataformas, se crean, ocasionalmente, archivos no deseados 
	 */
	public static String getDevNull() {
        String sys = System.getProperty("os.name");
        if (sys == null){
            return "junk";
        }
        if (sys.startsWith("Windows")){
            return "NUL";
        }
        return "/dev/null";
	}

}

_JavaDevelopment/javasrc-main/src/com/others/SysDep_02.java

package com.others;

public class SysDep_02 {
	/*
	 * Hay otro caso en el que es necesario comprobar el sistema operativo.
	 * Mac OS X tiene una serie de utilidades de interfaz de usuario.
	 * Apple señala que busque la cadena mrj.version para determinar si OS X se encuentra en ejecución:
	 */
	public static String getDevNull() {
        String isMacOS = System.getProperty("mrj.version");
        System.out.println("isMacOS: " + isMacOS);
        if (isMacOS == null){
            return "junk";
        }
        return "/dev/null";
	}
}

Si tiene un JAR de clases que quiere usar: 
- Copiar el archivo JAR en el directorio: /opt/java-jdk/jdk1.8.0_231/jre/lib/ext
Este directorio se examina cada vez que se inicia la máquina virtual de Java (JVM).
por lo tanto no es necesario reiniciar el equipo, aunque posiblemente si el IDE.
algunas API adoptan la forma de "extensiones estándar", porque los nombres de los paquetes comienzan por javax.

- Si el sistema en tiempo de ejecución JAVA no dispone de este mecanismo de extensiones; 
  lo más probable es que tenga que añadir cada archivo JAR al CLASSPATH.

Se puede analizar opciones de linea de comandos - review
https://www.gnu.org/software/gnuprologjava/api/gnu/getopt/Getopt.html
Java no ofrece ninguna API para ello, pero se puede analizar la matriz args como arguento en main.
java.lang.Object
  extended by gnu.getopt.Getopt

El objeto es INMUTABLE, es decir, no podrá cambiarse nunca.
_JavaDevelopment/testjdk_1.8.0.292/src/String3.java

Para cambiar los carácteres se necesita un objeto Mutable StringBuilder <==> StringBuffer

Clase a la que se consulta si la aplicación que se encuentra en funcionamiento puede hacer determinadas operaciones, como abrir archivos del disco local, abrir conexiones de red de forma arbitraria..etc.
SecurityManager
_JavaDevelopment/testjdk_1.8.0.292/src/???

Dividir una cadena en palabras o tokens - métodos: hasMoreTokens, hasMoreElements, nextToken, nextElement
_JavaDevelopment/javasrc-main/src/com/others/StringTokenizerTest.java

https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/StringTokenizer.html
Module java.base
Package java.util
Class StringTokenizer

Procesar e ignorar los tokens consecutivos, devolviendo los resultados como una matriz de cadenas.
_JavaDevelopment/javasrc-main/src/com/others/StringTokenizerTest_02.java

Unir cadenas mediante +, StringBuilder y StringBuffer
* Todos los métodos que modifican más de un carácter de contenido de un StringBuilder 
* (append, delete, deleteCharAt, insert, replace, reverse), 
* devuelven una referencia al objeto que facilita la codificación

Unir algunos fragmentos de String
https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuffer.html
Module java.base
Package java.lang
Class StringBuffer

https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html
Module java.base
Package java.lang
Class StringBuilder

_JavaDevelopment/javasrc-main/src/com/others/StringBufferTest.java

Convertir una lista de elementos en una lista separada por comas - StringBuffer
_JavaDevelopment/javasrc-main/src/com/others/StringBufferTest_02.java

Procesar una cadena carácter a carácter, utilizando un bucle for y el método charAt()
_JavaDevelopment/testjdk_1.8.0_292/src/String4.java

Realizar la suma de comprobación de un archivo, dado un BufferedReader abierto
permite leer "fragmentos" de datos con el método readLine() de BufferedReader
Lee carácter a carácter de un fichero y va sumando el valor ASCII de cada uno de ellos
_JavaDevelopment/javasrc-main/src/com/others/ChekSum.java

https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/BufferedReader.html

Module java.base
Package java.io
Class BufferedReader

    java.lang.Object
        java.io.Reader
            java.io.BufferedReader 

https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FileReader.html

Module java.base
Package java.io
Class FileReader

    java.lang.Object
        java.io.Reader
            java.io.InputStreamReader
                java.io.FileReader 

Leer un fichero sin más
_JavaDevelopment/javasrc-main/src/com/others/ReadFile.java
fileReader.txt

Leer un fichero e imprimirlo
- implementando try catch en el main
_JavaDevelopment/javasrc-main/src/com/others/LeerEImprimirFichero.java
- implementando throws en el main
_JavaDevelopment/javasrc-main/src/com/others/LeerEImprimirFicheroThrows.java

Class Format

https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/Format.html
Module java.base
Package java.text
Class Format

    java.lang.Object
        java.text.Format 

            DateFormat, MessageFormat, NumberFormat

Module java.base
Package java.text
Class DateFormat

    java.lang.Object
        java.text.Format
            java.text.DateFormat 

    All Implemented Interfaces:
        Serializable, Cloneable

    Direct Known Subclasses:
        SimpleDateFormat 

Module java.base
Package java.text
Class SimpleDateFormat

    java.lang.Object
        java.text.Format
            java.text.DateFormat
                java.text.SimpleDateFormat 

    All Implemented Interfaces:
        Serializable, Cloneable 

https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html
Alinear cadenas a la izquierda, a la derecha o al centro
Hacer los calculos y emplear substring y StringBuilder.
_JavaDevelopment/javasrc-main/src/com/others/FormatTest_03.java

- Format y jugando con align
// alinear a la izquierda - Left justifies
- Se crea el método espacios que recibe dos argumentos, un StringBuffer, y un entero que es el calculo de los espacios
  devuelve un StringBuffer 
_JavaDevelopment/javasrc-main/src/com/others/FormatTest_02.java

JUST_RIGHT ==> maxChars = espacios + sb
JUST_LEFT ==> maxChars = sb + espacios
JUST_CENTER ==> maxChars = espacios + sb + espacios

- Alinear cadenas a la izquierda, a la derecha o al centro utilizando la clase StringAlign.java
- Extiende de Format
- Se imprementan los métodos abstractos de la clase Format
_JavaDevelopment/javasrc-main/src/com/darwinsys/lang/StringAlign.java

https://www.programcreek.com/java-api-examples/?api=java.text.Format

Formatear tipo Date a String "yyyy/MM/dd - HH:mm:ss"
_JavaDevelopment/javasrc-main/src/com/others/FormatTest.java

Module java.base
Package java.text
Class MessageFormat

    java.lang.Object
        java.text.Format
            java.text.MessageFormat 

    All Implemented Interfaces:
        Serializable, Cloneable 

- Convertir entre carácteres Unicode y String - http://www.unicode.org
char y Unicode tienen un ancho de 16 bits
un char puede incluir cualquier carácter Unicode.
- el método charAt() de String devuelve un carácter Unicode
- el método append() de StringBuilder tiene una forma que acepta un valor char.
Dado que char es un tipo entero, es posible realizar cálculos en chars

_JavaDevelopment/javasrc-main/src/com/others/UnicodeChars.java

- Invertir una cadena por palabra o carácter

- StringBuilder permite invertir una cadena.
_JavaDevelopment/javasrc-main/src/com/others/StringReverseChars.java
_JavaDevelopment/testjdk_1.8.0_292/src/String4.java

- Tambien se podria con un StringTokenizer y una "pila" Stack LIFO.
_JavaDevelopment/javasrc-main/src/com/others/StringReverseLIFOChars.java

- Convertir cadenas de MAYUSCULAS a minusculas.
- Comparar cadenas sin tener en cuenta si estan escritas en MAYUSCULAS Ó minusculas
utilizando equals, equalsIgnoreCase
_JavaDevelopment/javasrc-main/src/com/others/StringIgnoreCase.java

- Identar (aumentar o insertar) una sangría a un documento de texto
_JavaDevelopment/javasrc-main/src/com/others/StringIdentar.java
_JavaDevelopment/javasrc-main/src/com/others/StringIdentarCadenaFija.java

- DesIdentar (reducir ó eliminar) una sangría a un documento de texto
_JavaDevelopment/javasrc-main/src/com/others/StringDesIdentar.java

- Incluir caracteres no imprimibles - especiales - en un documento
_JavaDevelopment/javasrc-main/src/com/darwinsys/strings/StringEscapes.java

Escapes de cadena:

Tabulación: \t
Avance o salto de línea: \n
Final de línea: System.out.println("separador de linea del sistema: " + System.getProperty("line.separator"));
Retorno de carro: \r
Avance de página: \f
Retroceso: \b
Comillas sencillas: \'
Comillas dobles: \"
Carácter Unicode: \uNNNN - Cuatro dígitos hexadecimales
Carácter Octal(!): \NNN - base 8
Barra invertida: \\


- Recortar espacios al principio y al final de una cadena
System.out.println("cadena.trim: " + cadena.trim());

- Herramienta para incluir/excluir partes de un archivo.
_JavaDevelopment/javasrc-main/src/com/darwinsys/strings/GetMark.java

ojo -  Probar este Script
------
for f in *.java
do
    echo $f
    java GetMark $f &gt; ../salida/$f
done

Ejecuta la clase GetMark e imprime el fichero spc.java sin los comentarios
ya que estos estan entre las marcas //- y //+
en este caso se utiliza el main de la clase que lo que se encarga de los nombres de los archivos y
de abrir archivos y cosas por el estilo
base) hadoop@sc-ubuntu-20-04-2-lts:~/SCProjects/0_SCProjects_github.com_SCelisV/_JavaDevelopment$ java javasrc-main/src/com/darwinsys/strings/GetMark.java javasrc-main/src/testing/spc.java 

- Leer una línea tipo CSV
    - Puede suceder que los campos del csv vengan con comillas y/o sin comillas y separados por lo que sea
    - La clase CSV java tiene dos constructores
        - la que se inicializa con el separador por defecto (,)
        - otro que se inicializa con el separador que indiquemos
        Esta clase a su vez tiene un método parser() que toma una cadena que representa una línea del archivo de entrada y devuelve una lista de campos de la que se puede obtener un Iterator para controlar el bucle y su método next() para obtener el objeto siguiente.

_JavaDevelopment/javasrc-main/src/com/others/CSV.java
_JavaDevelopment/javasrc-main/src/com/others/CSVSimple.java
    - La clase CSVSimple testea la clase CSV java.
        - Se puede utilizar inicializando el objeto:
        - CSV() que útilizará la (,) definida como separador por defecto en la clase ó 
        - CSV('-') que útilizará el '-' como separador
        
/* REGEXP - Expresiones Regulares
la idea es que lee del teclado InputStreamBuffer y analiza cada campo teniendo en cuenta que el separador de campos es una ',' como se ha definido en el CSV_PATTERN
crea grupos de caracteres que coincidan con el pattern, hasta incluir el separador 
y luego lo evalua, primero quita la (,); después quita las (") iniciales y finales 

_JavaDevelopment/javasrc-main/src/com/others/CSVRE.java
ejemplo de ejecución escribiendo la línea: "LU",86.25,"11/4/1998","2:19PM",+4.0625
CSV_PATTERN: 
"([^"]+?)",?|([^,]+),?|,
"LU",86.25,"11/4/1998","2:19PM",+4.0625
line = `"LU",86.25,"11/4/1998","2:19PM",+4.0625'

 m.group(): "LU",
 match.endsWith: "LU"
 match.starsWith: LU

 m.group(): 86.25,
 match.endsWith: 86.25

 m.group(): "11/4/1998",
 match.endsWith: "11/4/1998"
 match.starsWith: 11/4/1998

 m.group(): "2:19PM",
 match.endsWith: "2:19PM"
 match.starsWith: 2:19PM

 m.group(): +4.0625
encontrados: 5 items.                       --> porque el separador es un (-)
LU,
86.25,
11/4/1998,
2:19PM,
+4.0625,

ejemplo de ejecución escribiendo la línea: LU-86.25-11/4/1998-2:19PM-+4.0625
line = `LU-86.25-11/4/1998-2:19PM-+4.0625'

 m.group(): LU-86.25-11/4/1998-2:19PM-+4.0625
encontrados: 1 items.                       --> porque el separador es un (-)
LU-86.25-11/4/1998-2:19PM-+4.0625,

ejemplo de ejecución escribiendo la línea: LU,86.25,11/4/1998,2:19PM,+4.0625
LU,86.25,11/4/1998,2:19PM,+4.0625
line = `LU,86.25,11/4/1998,2:19PM,+4.0625'

 m.group(): LU,

 match.endsWith: LU

 m.group(): 86.25,

 match.endsWith: 86.25

 m.group(): 11/4/1998,

 match.endsWith: 11/4/1998

 m.group(): 2:19PM,

 match.endsWith: 2:19PM

 m.group(): +4.0625
encontrados: 5 items.                       --> porque el separador es un (-)
LU,
86.25,
11/4/1998,
2:19PM,
+4.0625,

LU;86.25;11/4/1998;2:19PM;+4.0625
line = `LU;86.25;11/4/1998;2:19PM;+4.0625'

 m.group(): LU;86.25;11/4/1998;2:19PM;+4.0625
encontrados: 1 items.                       --> porque el separador es un (;)
LU;86.25;11/4/1998;2:19PM;+4.0625,


/* REGEXP - Expresiones Regulares
CygWin
GnuWin32
grep --> g/RE/p
sed
awk
java.util.regex

Mastering Regular Expressions - Jeffrey E. F. Friedl

una expresión regular puede estar formada por hasta tres partes
- Pattern (patrón de búsqueda) 	
El elemento central es el patrón, esto es, el patrón de búsqueda general. 
Se puede formar a partir de caracteres simples o a partir de una combinación de caracteres simples y especiales. 

- Delimiter (delimitador) 	
El inicio y el final del patrón se identifican con delimitadores. 
Los delimitadores son, básicamente, todos los caracteres no alfanuméricos (excepto la barra diagonal inversa). 
Por ejemplo, para PHP las almohadillas (#pattern#), los signos de porcentaje (%pattern%), el signo más (+pattern+) o las tildes (~pattern~) son delimitadores. 
La mayoría de lenguajes ya usan las comillas (“pattern”) o las barras diagonales (/pattern/). 

- Modifier (modificador) 	
Los modificadores pueden añadirse a un patrón de búsqueda para modificar la expresión regular. 
Un ejemplo es el modificador i, el cual anula la distinción entre mayúsculas y minúsculas. 
Garantiza que las mayúsculas y las minúsculas se tienen en consideración y que valen por defecto para todas las expresiones regulares. 

a+ significa cualquier número de ocurrencias de la letra a
Mrs?\ coincide con Mr. ó Mrs. y .* isgnifica cualquiercarácter, un numero de veces indeterminado 
\d+ cualquier número de digitos numéricos
\d(2,3) significa un número de dos o tres dígitos
'An[^ dn]' significa todas las palabras que comienzan por 'An' seguidas de un caracter que no sea espacio ni d ni n
grep "[13]" busca los números 1 y 3
grep "[13-5]" busca el 1 y del 3 al 5
grep "([13-5]" busca el ( el 1 el 3 el 4 el 5 , también (1 el (3 el (4 el (5
grep "[1-3][a-c]" busca todo lo que empieza por los números 1, 2, 3 y continua con una letra a, b, c
grep "[1-3][A-C]" busca todo lo que empieza por los números 1, 2, 3 y continua con una letra A, B, C
grep "[1-3][a-cA-C]" busca todo lo que empieza por los números 1, 2, 3 y continua con una letra a, b, c, A, B, C
grep "c[^o]sa" busca todo lo que contiene la c seguido por cualquier cosa que no sea la o y termina en sa
grep "c.sa" el punto puede ser cualquier cosa
grep "c.sa\|cosa" busca cualquiera de las dos opciones como un or hay que escaparlo (\|) 
grep "\(Lun\|Mart\|Miércol\|Juev\|Viern\)es\|Sábado\|Domingo" busca todos los días de la semana
grep "emp\(la\)\+" busca todo lo que contiene emp y la mas lo demás
grep "\(VW \(Golf\|Polo\)\|Fiat \(Punto\|Panda\)\)" busca VW seguido por lo que sea Golf o Polo y Fiat seguido por lo que sea Punto o Panda
grep "c[^o]sar\\b" busca lo que termina en casar, cesar, cisar, cusar,
grep "\\biden" busca todo lo que empieza con iden
grep "\\btokens\\b" busca la palabra exacta
grep "11\.10\.2019" busca una fecha del tipo 11.10.2019
grep "A.*B" busca todo lo que contenga una A y una B, sin importar lo que haya en medio 
grep "A.?*B" busca todo lo que contenga una A un sólo caracter y después una B
grep "^A.?*B" busca todo lo que empieza con una A un sólo caracter y después una B
grep "A.?*B$" busca todo lo que termina con una A un sólo caracter y después una B
grep "Juan.*Caceres" busca todos los Juan Caceres
grep "^T[aeiou]\\w" busca todas las líneas que empiezan por T seguida de cualquier vocal y cualquier caracter alfanumérico
grep "^Q[^u][0-9][0-9][0-9]" busca algo del tipo Qe555
grep "^Q[^u]\\w\+" busca algo del tipo Qe555 - con \d no me funciono... :(

CSVRE.java
"\"([^\"]+?)\",?|([^,]+),?|,"
 * - busca un campo con comillas, 
 * - busca un campo sin comillas,
 * - busca un campo nulo.

--------

[...] 	Los corchetes identifican a una clase de caracteres que siempre representa a un único carácter en un patrón de búsqueda.
        cualquiera de los caracteres enumerados
[^..] 	Cualquier caracter no enumerado
(...) 	Los paréntesis identifican un grupo de caracteres formado por uno o varios caracteres y que pueden operarse unos dentro de los otros. - Agrupaciones

- 	Funciona a modo de especificación del área (de […] hasta […]) cuando se sitúa entre dos caracteres normales.
^ 	Limita la búsqueda al inicio de una línea (otra función: elemento de negación en clases de caracteres).
$ 	Limita la búsqueda al final de una línea.
. 	Equivale a cualquier carácter.
* 	El número del carácter, de la clase o del grupo situado antes del asterisco puede ser aleatorio (cero incluido).
+ 	El carácter, la clase o el grupo antes de un signo más debe aparecer como mínimo una vez.
? 	El carácter, la clase o el grupo antes del signo de interrogación es opcional y puede aparecer como máximo una vez.
|   Or

{n} 	El carácter, la clase o el grupo anteriores aparecen exactamente n veces.
{n,m} 	El carácter, la clase o el grupo anteriores aparecen entre mínimo n veces y máximo m veces.
{n,} 	El carácter, la clase o el grupo anteriores aparecen como mínimo n veces o más repeticiones

\A 	Inicio de una cadena completa
\b 	Tiene en cuenta el límite de palabra durante la búsqueda.
\B 	Ignora el límite de palabra durante la búsqueda.
\d 	Cualquier dígito; abreviatura para la clase de caracteres [0-9].
\D 	Cualquier no dígito; abreviatura para la clase de caracteres [^0-9].
\z 	Fin de una cadena completa
\Z 	Fin de una cadena completa, excepto el terminadore de línea final
\w 	Cualquier carácter alfanumérico; abreviatura para la clase de caracteres [a-zA-Z_0-9].
\W 	Cualquier carácter no alfanumérico; abreviatura para la clase de caracteres [^\w]. 

https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/package-summary.html

REGEXP - ejemplo de uso del paquete java.util.regex.*;
_JavaDevelopment/javasrc-main/src/com/others/RE.java

Interface 
MatchResult: The result of a match operation.

Tiene dos clases Class

Matcher:  An engine that performs match operations on a character sequence by interpreting a Pattern.
Pattern:  A compiled representation of a regular expression.

Exception: PatternSyntaxException Unchecked exception thrown to indicate a syntax error in a regular-expression pattern.



















Formatea texto como el fmt de Unix de Berkeley
_JavaDevelopment/javasrc-main/src/com/others/Fmt_pg130.java
para ejecutar utilizando un fichero: 
java javasrc-main/src/com/others/Fmt_pg130.java javasrc-main/src/com/others/fmt.txt




















































































































Exercises 

- Fill in the missing parts to print the value true:

int x = 10;
int y = 9;
    // Answer
System.out.println(x>10);

- Insert the missing parts to complete the following "short hand if...else statement" (ternary operator):

int time = 20;
String result = (time < 18)? "Good day." : "Good evening.";
System.out.println(result); 

- Insert the missing part to call myMethod from main.

static void myMethod() {
  System.out.println("I just got executed!");
}

public static void main(String[] args) {
    // Answer
    myMethod();
}

- Insert the missing part to call myMethod from main two times.

static void myMethod() {
  System.out.println("I just got executed!");
}

public static void main(String[] args) {
    // Answer
    myMethod();
    myMethod();
}

- Add a fname parameter of type String to myMethod, and output "John Doe".

    // Answer
static void myMethod(String fname){
    System.out.println(fname + " Doe")
}

public static void main(String[] args) {
    myMethod("John");
}

- Insert the missing part to print the number 8 in main, by using a specific keyword inside myMethod:

    // Answer
static void  myMethod(int x){
   return 5 + x;
}

public static void main(String[] args) {
  System.out.println(myMethod(3));
}

- Follow the comments to insert the missing parts of the code below:

// Create a checkAge() method with an integer variable called age
static void checkAge(int age) {

  // If age is less than 18, print "Access denied"
  if(age < 18) {
    System.out.println("Access denied"); 

  // If age is greater than, or equal to, 18, print "Access granted"
  }else{
    System.out.println("Access granted"); 
  }

} 

public static void main(String[] args) { 
  // Call the checkAge method and pass along an age of 20
  checkAge(20);
}

- Create a class called MyClass.

public class MyClass{

}

- Create an object of MyClass called myObj.

    MyClass myObj = new MyClass();


- Use myObj to access and print the value of the x attribute of MyClass.

public class MyClass {
  int x = 5;

  public static void main(String[] args) {
    MyClass myObj = new MyClass();
    // Answer
    System.out.println(myObj.x);
  }
}

- Call myMethod on the object.

public class MyClass {
  public void myMethod() {
    System.out.println("Hello World");
  }

  public static void main(String[] args) {
    MyClass myObj = new MyClass();
    // Answer
    myObj.myMehtod();
  }
}

- Create and call a class constructor of MyClass
Follow the comments to insert the missing parts of the code below:


// Create a MyClass class
public class  MyClass{

  int x;  // Create a class attribute x

  // Create a class constructor for the MyClass class
  public MyClass() {
    x = 5;  // Set the initial value for the class attribute x to 5
  }

  public static void main(String[] args) {
    // Create an myObj object of class MyClass (This will call the constructor)
    MyClass myObj = new MyClass(); 
    // Print the value of x
    System.out.println(myObj.x);
  }
}

- The class below should not be inherited by other classes. Add the correct modifier:

    // Answer
    final class MyClass

- Fill in the missing parts to import the java.util.Scanner class from the Java API:

    // Answer
    import java.util.Scanner;

- The Car class should inherit the attributes and methods from the Vehicle class. Add the correct keyword to make this possible.

    // Answer
    class Car extends Vehicle

- Insert the missing parts to handle the error in the code below.

    // Answer

try{
  int[] myNumbers = {1, 2, 3};
  System.out.println(myNumbers[10]);
} catch (Exception e) {
  System.out.println("Something went wrong.");
}

- Insert the missing keyword to execute code, after try..catch, regardless of the result.

    // Answer
try {
  int[] myNumbers = {1, 2, 3};
  System.out.println(myNumbers[10]);
} catch (Exception e) {
  System.out.println("Something went wrong.");
} finally {
  System.out.println("The 'try catch' is finished.");
}

Switch

- Insert the missing parts to complete the following switch statement.

int day = 2;
switch (day) {
   case 1:
    System.out.println("Saturday");
    break;
   case 2:
    System.out.println("Sunday");
    break;
}

- Complete the switch statement, and add the correct keyword at the end to specify some code to run if there is no case match in the switch statement.

int day = 4;
switch (day) {
   case 1:
    System.out.println("Saturday");
    break;
   case 2:
    System.out.println("Sunday");
    break;
  default:
    System.out.println("Weekend");
}

- Print i as long as i is less than 6.

int i = 1;
while (i < 6) {
  System.out.println(i);
  i++;
}

- Use the do/while loop to print i as long as i is less than 6.

int i = 1;
do {
  System.out.println(i);
  i++;
}
while (i < 6);

- Use a for loop to print "Yes" 5 times:

for (int i = 0; i < 5; ) {
  System.out.println("Yes");
}


- Loop through the items in the cars array.

String[] cars = {"Volvo", "BMW", "Ford"};
for(String i : cars) {
  System.out.println(i);
}

- Stop the loop if i is 5.

for (int i = 0; i < 10; i++) {
  if (i == 5) {
    break;
  }
  System.out.println(i);
}

- In the loop, when the value is "4", jump directly to the next value.

for (int i = 0; i < 10; i++) {
  if (i == 4) {
    continue;
  }
  System.out.println(i);
}

- Create an array of type String called cars

    String[] cars = {"Volvo", "BMW", "Ford"};

- Print the second item in the cars array.
                    0   ,   1   ,   2
String[] cars = {"Volvo", "BMW", "Ford"};
System.out.println(cars[1]);

- Change the value from "Volvo" to "Opel", in the cars array.

String[] cars = {"Volvo", "BMW", "Ford"};
cars[0] = "Opel";
System.out.println(cars[0]);

- Find out how many elements the cars array have.

String[] cars = {"Volvo", "BMW", "Ford"};
System.out.println(cars.length);

- Loop through the items in the cars array.

String[] cars = {"Volvo", "BMW", "Ford"};
for (String i : cars) {
  System.out.println(i);
}

- Insert the missing parts to create a two-dimensional array. - dos dimensiones

int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };

- Sobrecarga - Overloading - multiple methods can have the same name with different parameters

int myMethod(int x)
float myMethod(float x)
double myMethod(double x, double y)

Consider the following example, which has two methods that add numbers of different type:

static int plusMethodInt(int x, int y) {
  return x + y;
}

static double plusMethodDouble(double x, double y) {
  return x + y;
}

public static void main(String[] args) {

  int myNum1 = plusMethodInt(8, 5);
  double myNum2 = plusMethodDouble(4.3, 6.26);
  System.out.println("int: " + myNum1);
  System.out.println("double: " + myNum2);

}

- Instead of defining two methods that should do the same thing, it is better to overload - sobrecargar one.

In the example below, we overload the plusMethod method to work for both int and double:

static int plusMethod(int x, int y) {
  return x + y;
}

static double plusMethod(double x, double y) {
  return x + y;
}

public static void main(String[] args) {

  int myNum1 = plusMethod(8, 5);
  double myNum2 = plusMethod(4.3, 6.26);
  System.out.println("int: " + myNum1);
  System.out.println("double: " + myNum2);
  
}

- Recursión - recursividad
_JavaDevelopment/javasrc-main/src/com/others/Recursion.java

La recursión es la técnica de hacer que una función se llame a sí misma. 
Esta técnica permite descomponer los problemas complicados en problemas sencillos que son más fáciles de resolver.

puede ser bastante fácil caer en la escritura de una función que nunca termina, o que utiliza cantidades excesivas de memoria o potencia del procesador. 
Sin embargo, cuando se escribe correctamente, la recursividad puede ser un enfoque muy eficiente y matemáticamente elegante de la programación.

public class myClass{
    
  public static int sum(int k) {
    if (k > 0) {
                // llamo a la función nuevamente con 9,8,7,6,5,4,3,2,1
      System.out.println(k);
      return k + sum(k - 1);
    } else {
      return 0;
    }
  }

  public static void main(String[] args) {
                // llamo a la función con 10
    int result = sum(10);
    System.out.println(result);         // 55
  }
  
}

Explicación: 

10 + sum(9)
10 + ( 9 + sum(8) )
10 + ( 9 + ( 8 + sum(7) ) )
...
10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + sum(0)









Patrones de diseño

https://refactoring.guru/es/design-patterns/catalog

Cual de los siguientes patrones de comportamiento, permite que un objeto se comporte de distinta forma dependiendo de su estado interno?

Patrón Iterator
Patrón Observer
Patrón State
Patrón Strategy
Patrón Visitor

Patrón Iterator, permite moverse a través de una lista o colección de datos sin usar una interfaz estándar o sin tener que conocer los detalles de la representación interna de los datos.
public interface Iterator{

    public Object First();
    public Object Next();
    public Object isDone();
    public Object CurrentItem();

}

Iterator es una opción que viene ya implementada en Java

public interface Enumeration{

    public boolean hasMoreElements();
    public Object nextElement();

}

El tipo Enumeration está incluido en las clases Vector() y Hashtable(); contienen un método elements que devuelve la enumeration de los datos de la clase:

    public Enumeration elements();

Este método produce instancias de la clase Enumeration.
Para moverse a través de la lista:

Enumeration e = vector.elements();
while(e.hasMoreElements()){
    String name = (String)e.nextElement();
    System.out.println(name);
}

Hashtable proporciona el método keys que devuelve una Enumeration de las keys para cada elemento de la tabla.

public Enumeration keys();

Patrón Strategy, Consiste en un número de algoritmos relacionados y encapsulados en una clase controladora llamada contexto.
El programa cliente puede seleccionar uno de esos algoritmos, o en algunos casos es el contexto el que selecciona el mejor.
La intención es alternar fácilmente entre algoritmos sin sentencias adicionales.
Encapsular varias estrategias en un simple módulo y proveer de una simple interfaz para elegir entre dichas estrategias. No todas ellas requieren ser miembros de una jerarquia de clase. No obstante deben tener implementada la misma interfaz.

El contexto decide cual estrategia emplear.
La decisión se basa en la solicitud del programa cliente y todo lo que tiene que hacer es que una variable apunte a una estrategia en concreto.

class MainApp{

    public static void main(String[] args) {

        Context context;

        context = new Context(new ConcreteStrategyA());
        context.execute();

        context = new Context(new ConcreteStrategyB());
        context.execute();

        context = new Context(new ConcreteStrategyC());
        context.execute();
        
    }
}

Las clases que implementan una determinada estrategia deben incluir:
Interface IStrategy {
    void execute();
}

class ConcreteStrategyA implements IStrategy{
    public void execute(){
        System.out.println("Called ConcreteStrategyA");
    }
}
...
...
Configurado con el objeto ConcreteStrategy y referenciado al objeto:

Strategy 

class Context{
     IStrategy strategy;

     //Constructor
     public Context(IStrategy strategy){
         this.strategy = strategy;
     }

     public void execute(){
         strategy.execute();
     }
 }

Patrón Observer, permite a un objeto notificar a otros objetos sobre cambios en su estado.
Proporciona una forma de suscribirse y cancelar la subscripción a estos eventos para cualquier objeto que implementa una interfaz suscriptora.

Patrón State, permite a un objeto alterar su comportamiento cuando su estado interno cambia. Parece como si el objeto cambiara su clase.

Patrón Visitor, permite separar algoritmos de los objetos sobre los que operan.
Patrón Command, convierte una solicitud en un objeto independiente que contiene toda la información sobre la solicitud.

Patrones creacionales, proporcionan mecanismos de creación de objetos que incrementan la flexibilidad y la reutilización del código existente: Factory Method, Abstract Factory 

Patrones estructurales, explican cómo ensamblar objetos y clases en estructuras más grandes, mientras se mantiene la flexibilidad y eficiencia de la estructura: Builder, Prototype, Singleton, Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy

Patrones de comportamiento, tratan con algoritmos y la asignación de responsabilidades entre objetos.
Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor 

Cual de los siguientes métodos se utiliza para comparar dos Strings en un programa Java?
Y si los Strings no coinciden, devuelve un valor distinto de cero.

equals
equalsIgnoreCase
compareTo   => Si el resultado es diferente de 0, son diferentes

Cual de las siguientes afirmaciones sobre Java String es falsa?

Java String es una clase en java y esta definida en el paquete java.lang
No es un tipo de datos primitivos como int y long
-- La clase String representa arrays de String
String es final por diseño de Java


superclase y una subclase?

Las SubClases heredan todos los miembros de su SuperClase, aunque NO todos los miembros tienen porque ser accesibles, es decir, Una superclase es la que sus caracteristicas se heredan, mientras que la subclase es una clase que hereda.

Interfaz, Es una colección de métodos abstractos. 
Una interfaz NO puede contener métodos implementados.
Una clase implementa una interfaz, heredando así los métodos abstractos de la interfaz.
En una interfaz solamente puede haber métodos públicos.

Todos los métodos de la interfaz deben definirse en la clase. Excepto si la clase es abstract.
Una interfaz puede contener cualquier número de métodos.
No se puede instanciar una interfaz.
Una interfaz no contiene ningún constructor.
Los únicos campos que pueden aparecer en una interfaz deben ser declarados estáticos y finales.
Una interfaz puede extender varias interfaces.


Clase Abstracta
Una clase abstracta puede contener métodos implementados.
En una clase abstracta, los métodos abstractos pueden ser public o protected. 


Escribir una interfaz es similar a escribir una clase. 
Pero una clase describe los atributos y comportamientos de un objeto. 
Y una interfaz contiene comportamientos que una clase implementa.

En Java los hilos/Thread están encapsulados en la clase Thread. 
Para crear un hilo tenemos dos posibilidades: 
- Heredar de Thread redefiniendo el método run(). 
- Crear una clase que implemente la interfaz Runnable que nos obliga a definir el método run()

?? npi - Synchronized ?? Dicho método sólo puede ser ejecutado por un hilo en un momento determinado 

Synchronized utilizan el cerrojo del objeto al que pertenecen evitando que más de un hilo entre en ellos al mismo tiempo

Los métodos sincronizados permiten una estrategia sencilla para evitar la interferencia de hilos y los errores de consistencia de memoria: si un objeto es visible para más de un hilo, todas las lecturas o escrituras en las variables de ese objeto se realizan a través de métodos sincronizados.
En pocas palabras: Cuando tienes dos hilos que están leyendo y escribiendo en el mismo 'recurso', digamos una variable llamada foo, necesitas asegurarte de que estos hilos acceden a la variable de forma atómica. Sin la palabra clave synchronized, tu hilo 1 puede no ver el cambio que el hilo 2 ha hecho en foo, o peor, puede ser que sólo haya cambiado la mitad. 

yield() --> Método estático de la clase Thread y puede detener el hilo que se está ejecutando actualmente y dará una oportunidad a otros hilos en espera de la misma prioridad. Si no hay hilos en espera o si todos los hilos en espera tienen baja prioridad, el mismo hilo continuará su ejecución.
wait() --> Este método está definido en la clase Object, que es la clase más importante de Java. Este método le dice al hilo que lo llama (hilo actual) que abandone el bloqueo y se vaya a dormir hasta que algún otro hilo entre en el mismo monitor y llame a notify() o notifyAll(). Es un método final, por lo que no podemos anularlo.
notify() --> Se utiliza para despertar un solo hilo que está esperando un objeto, y ese hilo entonces comienza la ejecución.
notifyAll() --> Despierta todos los hilos que están esperando en el monitor de este objeto. Un hilo espera en el monitor de un objeto llamando a uno de los métodos de espera. Los hilos despertados no podrán proceder hasta que el hilo actual renuncie al bloqueo de este objeto
sleep(1000) --> Se utiliza para pausar la ejecución del hilo actual durante el tiempo especificado en milisegundos. El valor del argumento para los milisegundos no puede ser negativo, de lo contrario lanza una IllegalArgumentException
Thread.join() --> Permanece en estado de espera hasta que el hilo referenciado termina. El método join() también puede devolver si el hilo referenciado fue interrumpido. En este caso, el método lanza una InterruptedException
Thread.killThread() --> Un hilo se destruye automáticamente cuando el método run() ha finalizado. Pero puede ser necesario kill/stop un hilo antes de que haya completado su ciclo de vida. Anteriormente, se utilizaban los métodos suspend(), resume() and stop() para gestionar la ejecución de los hilos.

Cual de las siguientes interfaces implementaría para una clase serializable:

// implements java.io.Serializable

La serialización es un mecanismo para convertir el estado de un objeto en un flujo de bytes. 
La deserialización es el proceso inverso en el que el flujo de bytes se utiliza para recrear el objeto Java real en la memoria. 
Este mecanismo se utiliza para persistir el objeto.

Comparable --> Si cualquier clase implementa la interfaz Comparable en Java, entonces la colección de ese objeto, ya sea Lista o Matriz, puede ser ordenada automáticamente utilizando el método Collections. sort() o Arrays. sort() y los objetos serán ordenados en base a su orden natural definido por el método CompareTo

Externalizable
La externalización se utiliza cuando necesitamos personalizar el mecanismo de serialización. Si una clase implementa una interfaz Externalizable entonces, la serialización del objeto se hará utilizando el método writeExternal().

OpenOption, Define interfaces y clases para que la máquina virtual Java acceda a archivos, atributos de archivos y sistemas de archivos. java.nio.file.spi.

Los hilos de un proceso
Un hilo es la unidad de ejecución de un proceso. 
Podemos dividir el proceso en subprocesos, y cada uno de ellos será un hilo de ejecución. 
Si un programa no es multi-hilo, los procesos dentro de él solamente tendrán un hilo, así que solamente se podrán procesar de una sola vez













-- diff

(base) hadoop@sc-ubuntu-20-04-2-lts:~/SCProjects/0_SCProjects_github.com_SCelisV/_JavaDevelopment$ diff javasrc-main/src/com/others/FormatTest_02.java $HOME/eclipse-workspace/javasrc-main/src/com/others/FormatTest_02.java 

-- compilar
(base) hadoop@sc-ubuntu-20-04-2-lts:~/SCProjects/0_SCProjects_github.com_SCelisV/_JavaDevelopment$ javac javasrc-main/src/com/others/FormatTest_02.java

-- ejecuatar
(base) hadoop@sc-ubuntu-20-04-2-lts:~/SCProjects/0_SCProjects_github.com_SCelisV/_JavaDevelopment$ java javasrc-main/src/com/others/FormatTest_02.java





























---------------------------------------------------------------------------------------------------------------

Instalación de java y eclipse en ubuntu

==========< install >==========
https://www.youtube.com/watch?v=PpDSz9zJVYI

Download oracle jdk

https://www.oracle.com/java/technologies/downloads/

x64 Debian Package 	138.3 MB 	
jdk-11.0.14_linux-x64_bin.deb

(base) hadoop@sc-ubuntu-20-04-2-lts:~$ ls j*
/home/hadoop
139M -rw-rw-r-- 1 hadoop hadoop 139M mar 28 13:57 jdk-11.0.14_linux-x64_bin.deb

(base) hadoop@sc-ubuntu-20-04-2-lts:~$ sudo dpkg -i jdk-11.0.14_linux-x64_bin.deb
Selecting previously unselected package jdk-11.
dpkg: warning: files list file for package 'mysql-workbench-community' missing; assuming package has no files currently installed
dpkg: warning: files list file for package 'libgrilo-0.3-0:amd64' missing; assuming package has no files currently installed
(Reading database ... 364197 files and directories currently installed.)
Preparing to unpack jdk-11.0.14_linux-x64_bin.deb ...
Unpacking jdk-11 (11.0.14-1) ...
Setting up jdk-11 (11.0.14-1) ...

(base) hadoop@sc-ubuntu-20-04-2-lts:~$ ls /usr/lib/jvm/
/home/hadoop
total 40K
4,0K drwxr-xr-x   9 10668 10668 4,0K mar 28 14:00 jdk-11

-- https://askubuntu.com/questions/315646/update-java-alternatives-vs-update-alternatives-config-java

(base) hadoop@sc-ubuntu-20-04-2-lts:~$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk-11/bin/java 1
(base) hadoop@sc-ubuntu-20-04-2-lts:~$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk-11/bin/javac 1

(base) hadoop@sc-ubuntu-20-04-2-lts:~$ sudo update-alternatives --config java
There are 5 choices for the alternative java (providing /usr/bin/java).

  Selection    Path                                            Priority   Status
------------------------------------------------------------
  0            /usr/lib/jvm/java-11-openjdk-amd64/bin/java      1111      auto mode
* 1            /opt/java-jdk/jdk1.8.0_231/bin/java              100       manual mode
  2            /usr/lib/jvm/java-11-openjdk-amd64/bin/java      1111      manual mode
  3            /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java   1081      manual mode
  4            /usr/lib/jvm/jdk-11/bin/java                     1         manual mode
  5            /usr/lib/jvm/jdk-11/bin/javac                    1         manual mode

Press <enter> to keep the current choice[*], or type selection number: 4

hadoop@sc-ubuntu-20-04-2-lts:~$ sudo update-alternatives --config java
There are 5 choices for the alternative java (providing /usr/bin/java).

  Selection    Path                                            Priority   Status
------------------------------------------------------------
  0            /usr/lib/jvm/java-11-openjdk-amd64/bin/java      1111      auto mode
  1            /opt/java-jdk/jdk1.8.0_231/bin/java              100       manual mode
  2            /usr/lib/jvm/java-11-openjdk-amd64/bin/java      1111      manual mode
  3            /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java   1081      manual mode
* 4            /usr/lib/jvm/jdk-11/bin/java                     1         manual mode
  5            /usr/lib/jvm/jdk-11/bin/javac                    1         manual mode


hadoop@sc-ubuntu-20-04-2-lts:~$ sudo update-alternatives --config javac
There are 4 choices for the alternative javac (providing /usr/bin/javac).

  Selection    Path                                          Priority   Status
------------------------------------------------------------
* 0            /usr/lib/jvm/java-11-openjdk-amd64/bin/javac   1111      auto mode
  1            /opt/java-jdk/jdk1.8.0_231/bin/javac           100       manual mode
  2            /usr/lib/jvm/java-11-openjdk-amd64/bin/javac   1111      manual mode
  3            /usr/lib/jvm/java-8-openjdk-amd64/bin/javac    1081      manual mode
  4            /usr/lib/jvm/jdk-11/bin/javac                  1         manual mode

Press <enter> to keep the current choice[*], or type selection number: 4

hadoop@sc-ubuntu-20-04-2-lts:~$ sudo update-alternatives --config javac
There are 4 choices for the alternative javac (providing /usr/bin/javac).

  Selection    Path                                          Priority   Status
------------------------------------------------------------
  0            /usr/lib/jvm/java-11-openjdk-amd64/bin/javac   1111      auto mode
  1            /opt/java-jdk/jdk1.8.0_231/bin/javac           100       manual mode
  2            /usr/lib/jvm/java-11-openjdk-amd64/bin/javac   1111      manual mode
  3            /usr/lib/jvm/java-8-openjdk-amd64/bin/javac    1081      manual mode
* 4            /usr/lib/jvm/jdk-11/bin/javac                  1         manual mode

hadoop@sc-ubuntu-20-04-2-lts:~$ javac -version
javac 11.0.14
hadoop@sc-ubuntu-20-04-2-lts:~$ java -version
java version "11.0.14" 2022-01-18 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.14+8-LTS-263)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.14+8-LTS-263, mixed mode)

hadoop@sc-ubuntu-20-04-2-lts:~$ cat hello.java
public class hello{

    public static void main (String[]args){
         System.out.println('\n');
         System.out.println("Hello World!");
    }
}

hadoop@sc-ubuntu-20-04-2-lts:~$ javac hello.java
hadoop@sc-ubuntu-20-04-2-lts:~$ java hello

Hello World!

==========< install >==========

# En este fichero he adicionado el JAVA_HOME
(base) hadoop@sc-ubuntu-20-04-2-lts:~$ sudo vi /etc/profile

JAVA_HOME=/usr/lib/jvm/java-11

hadoop@sc-ubuntu-20-04-2-lts:~$ echo $JAVA_HOME
/usr/lib/jvm/java-11

==========< install >==========

--------------< otra instalación >---------------
(base) hadoop@sc-ubuntu-20-04-2-lts:~$ sudo apt install openjdk-11-jdk
[sudo] password for hadoop: 
Reading package lists... Done
Building dependency tree       
Reading state information... Done
openjdk-11-jdk is already the newest version (11.0.14+9-0ubuntu2~20.04).
The following package was automatically installed and is no longer required:
  libfwupdplugin1
Use 'sudo apt autoremove' to remove it.
0 to upgrade, 0 to newly install, 0 to remove and 0 not to upgrade.
--------------< otra instalación >---------------

==========< install eclipse >==========
https://www.youtube.com/watch?v=Bhgnz6aZg1Y

Download Website https://www.eclipse.org

Get Eclipse IDE 2022‑03

eclipse-inst-jre-linux64.tar.gz

hadoop@sc-ubuntu-20-04-2-lts:~$ tar -xvzf eclipse-inst-jre-linux64.tar.gz
hadoop@sc-ubuntu-20-04-2-lts:~$ cd eclipse-inst-jre-linux64/eclipse-installer/
hadoop@sc-ubuntu-20-04-2-lts:~/eclipse-inst-jre-linux64/eclipse-installer$ ./eclipse-inst

Java 11 + VM --> normalmente reconoce donde esta instalado java 11  /
Instalation Folder --> /home/hadoop/eclipse/java-2022-032

Creación del espacio de trabajo:
/home/hadoop/eclipse-workspace

Project > Clean...

1-Right CLick on your project folder, Choose Build Path > Configure Build Path
2-Select Libraries Tab and delete any arbitrary library present there.
3-Click on Add Library option, Select JRE System Library and click Next.
4-Choose last Radiobutton option Workspace default JRE and click Finish.
5-press f5 for refresh.
6-run program 


==========< install eclipse >==========