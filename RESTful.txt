representational state transfer application programming interface REST API  
nos permiten separar completamente la presentación del contenido del contenido en sí

When the visitor navigates from one page to another, they send a URL, Universal Resource Locator, request to the server pointing at a web resource in the form of a specific HTML document. 
The server responds by returning the document along with its adjoining files to the browser which replaces the previous content with all new content. 
This works fine, but it's resource intensive. 
Each new page requires a completed HTML document and the document has to be written by a developer or generated by a content management system before it's downloaded and rendered in the browser.

En lugar de un sitio web compuesto por documentos individuales generados y descargados del servidor, tenemos una aplicación web. (Cada página es una vista que representa el estado actual)
When the visitor loads the site for the first time, all the components that make up the application are downloaded including an HTML framework, referenced items, one or more style sheets, and some JavaScript. 
The application then sends a URI or Universal Resource Identifier request for a web resource representing the next state of the application to be transferred, and uses the resulting data to build the current view. 
When the visitor navigates from one view to another, the application sends a new URI request for the web resource representing the next state of the application which is transferred and used to add, modify, replace, or delete the previous data. 
The key is this representational state is transferred as a data object, not the entire new set of files. And the application can update its data without rendering the whole new page.

aplicaciones de una sola página en la web y aplicaciones nativas para dispositivos móviles. controladas por API, que es un conjunto de características y reglas que existen dentro de un programa de software que permite la interacción entre el software y otros elementos, como otro software o hardware
In the context of REST APIs, API (like a language to talk with REST), is the collection of tools used to access and work with REST resources through your adverbs including get, pulls, put, and delete.


URI or Universal Resource Identifier, is described as a "compact sequence of characters "that identifies an abstract or physical resource" that "provides a simple and extensible means "for identifying a resource." 
The URI is the most generic method for naming and locating a web resource.

URL, or Universal Resource Locator, is a subset of the URI. The URL not only identifies a resource, but also explains how to access that resource by providing an explicit method like HTTP or FTP. 
In other words, all URLs are URIs, but not all URIs are URLs. 
There's also another subset of URIs we rarely talk about, the URN, or Universal Resource Name. 

URN, or Universal Resource Name. refers to both URIs under the URN scheme and to any other URI with the properties of a name. 
The classic explanation of the difference between a URN and a URL is to say the URN is a unique name identifier, like the name of a person. 
The URL provides my actual physical location.

Representational state transfer, or REST, refers to a group of software architecture design constraints that bring about efficient, reliable, and scalable systems. 
There are six of these constraints and to understand REST - 

API RESTful debe cumplir:

- Constraint number one, arquitectura cliente-servidor. client-server architecture. This constraint ensures proper separation of concerns. 
servir a muchos clientes e interfaces diferentes sin saber o preocuparse por el aspecto
The client manages user interface concerns, while the server manages data storage concerns. 
In return, we get a highly portable system where one REST service can serve many different clients and interfaces without knowing or caring what those interfaces look like or what they are doing. 
In short, we have a complete separation between the content and its presentation and interaction.

- Constraint number two, statelessness. Ausencia de estado. No client context or information, AKA state, can be stored on the server between requests. 
The client is responsible for keeping track of its own session state and all requests sent from a client must be self-contained and complete. 
If the client's session state is relevant, it must be sent along with a request and if the server needs to store that state, it must pass it on to a database or similar service for a specific time. 
ex: token for a set period of time to allow authenticated requests. 

- Constraint number three, cacheability. Almacenamiento en cache. Cacheing is an intricle part of web architecture and performance optimization. 
All REST responses must be clearly marked as cacheable or non-cacheable.
almacenar en caché las respuestas que no van a cambiar o que es poco probable que cambien, 
almacenar en caché las respuestas que cambian rara vez o periódicamente durante períodos de tiempo razonables, y 
bloquear el almacenamiento en caché para las respuestas que cambian constantemente

- Constraint number four, layered system. sistema por capas
el cliente no pueda saber y no le importe si está conectado directamente al servidor o a un intermediario como una réplica o una CDN. ( scalability and also helps with security. )

- Constraint number five, code on demand. código bajo demanda. 
Los servidores pueden transferir código ejecutable en forma de JavaScript del lado del cliente y componentes compilados al cliente para ampliar y personalizar la funcionalidad. no es común. 

- Constraint number six, uniform interface, Una interfaz uniforme debe utilizar la identificación de recursos en las peticiones.
En un REST de la web, se utiliza una URI para enviar una petición y esa URI especificará qué recurso está buscando. So a URI requiere a resource. 
el recurso son los datos que se encuentran en el servidor. Lo que REST devuelve es una representación de ese recurso que puede tener un formato diferente del recurso del servidor
mientras que los datos del recurso pueden ser almacenados como una tabla en mi SQL, la representación de retorno puede ser JSON o XML o incluso HTML. 
el cliente, con el nivel de acceso adecuado, puede controlar lo que se almacena en el servidor. 
la interfaz debe emitir mensajes autodescriptivos - sending and receiving REST data. 
Each representation must describe its own data format. si se recibe JSON, se envia JSON
la interfaz debe usar hypermedia, es decir, el cliente debe ser capaz de descubrir todos los recursos y métodos disponibles a través de los hipervinculos proporcionados.
el servicio REST describe su propio uso con cada recurso devuelto.

Restful, es cuando un servicio REST se ejecuta en la web a través de HTTP para darnos acceso a un recurso web. La plataforma web es lo que hace que sea RESTful.

El trabajo de la API REST es recibir solicitudes, procesar datos y enviar respuestas.

Ex: REST-API pública de Sandbox: REQ/RES. https://reqres.in, tiene una lista de un montón de peticiones diferentes que puedes enviar y también modela las respuestas de las peticiones, para ver exactamente lo que está pasando
Reqres.in es una API RESTful que utiliza el protocolo HTTP para las solicitudes. 
Según la doc: para obtener una lista de usuarios: GET LIST USERS, la Request es: /api/users?page=2

https://reqres.in/api/users?page=2
si todo va bien devolvera un ok = 200 y mostrara la lista de usuarios
los datos están formateados pero son "difíciles" de leer, por lo que para hacer legible la respuesta, necesitamos un cliente REST asignado para este propósito ( Postman e Insomnia )
Visual Studio Code tiene una extensión de cliente REST: REST Client

0_DEVELOP__0_DEVELOP__0_DEVELOP__/REST-APIs/rest.http -> este archivo contiene nuestra petición:  GET https://reqres.in/api/users 
command+option+r -> abre un panel que contiene la cabecera completa de la respuesta REST con toda la meta información sobre la respuesta y también formatea los datos y la cabecera de una manera legible

example using WordPress REST API: installed version of WordPress running under the domain restful.dev - https://restful.dev/wp-admin/edit.php (no works)

the anatomy of a REST request.  Methods and Resource URI
Methods: are standard HTTP operators, get, post, put, patch, delete, options, and head.
Resource URI: https://restful.dev/posts/5

los métodos funcionarán en el recurso al final de la URI proporcionada dependiendo de la configuración de la API REST y de las capacidades autorizadas del usuario actual.

Por lo tanto, si queremos una lista de las publicaciones más recientes de un sitio de WordPress, enviamos una solicitud GET a la URI de recursos para todas las publicaciones, 
GET site.com/wp-json/wp/v2/posts
GET /wp-json/wp/v2/posts

Cuando enviamos una solicitud, también podemos enviar metadatos en la cabecera de la solicitud. 
Estos datos deben incluir el tipo de contenido para cumplir con las restricciones de los mensajes autodescriptivos y 
también pueden contener una cadena de agente de usuario, 
cadena de idioma aceptada, 
autenticación, 
control de caché y más. 
GET /wp-json/wp/v2/posts/ 
HTTP/1.1 
Host: appsite.dev 
Content-Type: 
application/json 
Authorization: Basic dG9t0nBhc3N3b3Jk 
Cache-Control: no-cache

Para enviar información a la API REST y crear una nueva entrada o actualizar una existente, 
la solicitud se vuelve más compleja porque tenemos que enviar los datos reales. 
En este caso, la estructura de datos de la solicitud debe coincidir con el tipo de contenido definido en la solicitud. 
enviamos una petición POST al recurso de la entrada a través del mismo URI que antes. 
y luego incluir los datos JSON reales a ser publicados. 

POST /wp-json/wp/v2/posts/ 
HTTP/1.1 
Host: appsite.dev 
Content-Type: application/json 
Authorization: Basic Sonia pass 
Cache-Control: no-cache
{
"title":"Sonia creates a new task generated from the REST API",
"content":"This is the content for the new post.",
"author": 10,
}

normalmente no tenemos que escribir estas peticiones, algunos de los metadatos pueden ser manejados automáticamente. 
En una aplicación normal, se usan scripts para manejar las peticiones y respuestas, normalmente alguna forma de JavaScript. 
En el viejo JavaScript, la petición GET sería:

var xhr = new XMLHttpRequest();
xhr.open("GET", "https://site.com/wp-json/wp/v2/posts/", true);
xhr.onload = function(){
    console.log(xhr.responseText);
};
xhr.send();

Aquí, abrimos la petición GET a un URI especificado y luego capturamos las respuestas para registrarlas en la consola. 

Usando jQuery AJAX, la petición POST sería:

$.ajax({
    url: "https://site.com/wp-json/wp/v2/posts/",
    type: "POST",
    data:{
        title: "Sonia creates a new task generated from the REST API",
        content:"This is the content for the new post.",
        author: 10,
    },
    success: function(response){
        console.log(response);
    }
});

Aquí, hacemos lo mismo, definimos un URI, enviamos una petición POST a él, añadimos algunos datos y en caso de éxito, capturamos la respuesta para registrarla en la consola.

la API REST se describirá a sí misma, utilizando los verbos get y options, 
GET
OPTIONS
podemos recorrer la respuesta de cualquier API REST, para encontrar sus recursos y métodos. 
Para una API REST sencilla, el mapa podría ser un único nivel de URIs de recursos con métodos get. 
Para una API REST más compleja, puede haber un árbol complejo de recursos, cada uno con sus propios métodos que están documentados dentro de la respuesta.

OPTIONS http://restful.dev/wp-json/wp/v2/posts

Aquí, obtenemos un desglose completo de todos los recursos y métodos disponibles. 
En la parte superior, 
recurso posts tiene dos métodos principales: get, que nos devuelve los posts más recientes, y post, que vamos a utilizar para crear nuevos posts. 
Bajo cada uno de estos métodos, tenemos definidos otros argumentos.

tip: si llegas a una API REST sin saber nada de ella, con OPTIONS obtienes toda la información que necesitas para enviar solicitudes avanzadas y obtener la información que quieres, directamente de esa API REST.

Recurso: cualquier concepto que pueda ser objeto de una referencia hipertextual por parte de un autor, debe encajar en la definición de recurso. 
Un recurso es un mapeo conceptual a un conjunto de entidades.
Normalmente, la estructura de una API REST permite acotar las peticiones de recursos de colecciones, dos singletons, mediante una mayor especificidad en la ruta URI.
Representación: los componentes REST realizan acciones sobre un recurso utilizando una representación para capturar el estado actual o previsto de ese recurso y transfiriendo esa representación entre los componentes.
es decir, en lugar de acceder a los datos reales del recurso, accedemos a una representación, una copia de ese recurso. el servidor REST genera una representación o copia única 

Esta es la razón por la que un recurso REST puede servir los mismos datos a múltiples clientes al mismo tiempo, 
y por la que un recurso REST puede servir diferentes variantes de esos datos a diferentes clientes a petición. 
Los datos pueden ser almacenados como XML, pero la representación de esos datos servidos a un cliente, puede ser JSON o HTML o cualquier otro formato. 
Por lo tanto, 
el recurso es cualquier dato que se encuentra en la ubicación a la que estamos apuntando, 
la representación es la representación literal de los datos que obtenemos cuando accedemos a ese recurso.

https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
HTTP status are split into five main groups:

1xx information
2xx Success
    200 OK
    201 Created
    204 No content
3xx Redirection
    301 Moved permanently
    302/303 Found at this other URL
    307 Temporary redirect
    308 Resume incomplete
4xx Client error
    400 Bad request
    401 Unauthorize
    403 Forbidden
    404 Not Found
    405 Method Not Allowed
5xx Server error
    500 Internal server error
    502 Bad gateway
    503 Service unavailable

Obtener the specified resource, if available
GET - 
200 OK, 404 Not Found

Create a new resource and add it to a collection
POST - 
201 Created, 401 Unauthorized, 409 Conflict, 404 Not Found

Update an existing singleton resource based on ID
PUT - 
200 OK, 401 Unauthorize, 404 Not Found, 405 Method Not Allowed

Modify an existing singleton resource based on ID
PATCH - 
200 OK, 401 Unauthorize, 404 Not Found, 405 Method Not Allowed

DELETE -
can only be used with singleton resources
200 OK, 401 Unauthorize, 404 Not Found
if you try to delete a collection resources 405 Method Not Allowed

Get the options available from this resource
OPTIONS - 
200 OK

Get just the response headers from the resource
HEAD - 
200 OK, 404 Not Found

HEAD https://reqres.in/api/users

tiene una larga lista de argumentos, podemos usar esos argumentos y la forma de hacerlo es encadenándolos en la URLs. 
Así que después del recurso posts, signo de interrogación y luego usamos el argumento
GET http://restful.dev/wp-json/wp/v2/posts?per_page=1

En la parte superior de cada uno de los objetos post, encontraremos id y un poco más abajo la propiedad link. 
si me desplazo a la parte inferior de este objeto post después de todo el contenido, 
links y bajo la propiedad links esta self y href y este es el enlace de recurso a este recurso en particular. 
Y en la siguiente línea un enlace a la colección. 

aquí sólo recuperamos este post,
GET http://restful.dev/wp-json/wp/v2/posts/4

POST http://restful.dev/wp-json/wp/v2/posts/ 
Authorization: Basic Sonia pass 
Content-Type: application/json 

{
    "title":"Sonia creates a new task generated from the REST API",
    "content":"This is the content for the new post.",
    "status": "publish",
    "author": 1
}

PUT http://restful.dev/wp-json/wp/v2/posts/15
Authorization: Basic Sonia pass 
Content-Type: application/json 

{
    "title": "The New REST API Post Title",
}

en este caso nuestro método no borra la información cambia el status a "trash"
DELETE http://restful.dev/wp-json/wp/v2/posts/15
Authorization: Basic Sonia pass 

y si quiero borrarlo debo usar el argumento force
DELETE http://restful.dev/wp-json/wp/v2/posts/15?force=true
Authorization: Basic Sonia pass 


